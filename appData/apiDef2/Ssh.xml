<?xml version="1.0" encoding="utf-8" ?>
<class XojoModuleId="649209598" license="Ssh" hasEvents="1" baseProgress="1" sourceXmlPath="C:/ck2000/appData/apiDef2/Ssh.xml">
    <axName>ChilkatSsh</axName>
    <dnName>Ssh</dnName>
    <cppName>CkSsh</cppName>
    <properties>
        <property name="AuthFailReason" read="1" ax="1" cpp="1" dn="1" axId="192">
            <gType>int</gType>
            <descrip>Set to one of the following values if a call to AuthenticatePw, AuthenticatePk, or AuthenticatePwPk returns a failed status.
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;1: &lt;/b&gt;Transport failure. This is a failure to communicate with the server (i.e. the connection was lost, or a read or write failed or timed out).
&lt;li&gt;&lt;b&gt;2: &lt;/b&gt;Invalid key for public key authentication.  The key was not a valid format, not a valid key, not a private key, or not the right type of key.
&lt;li&gt;&lt;b&gt;3: &lt;/b&gt;No matching authentication methods were available.
&lt;li&gt;&lt;b&gt;4: &lt;/b&gt;SSH authentication protocol error - an unexpected or invalid message was received.
&lt;li&gt;&lt;b&gt;5: &lt;/b&gt;The incorrect password or private key was provided.
&lt;li&gt;&lt;b&gt;6: &lt;/b&gt;Already authenticated.  The SSH session is already authenticated.
&lt;li&gt;&lt;b&gt;7: &lt;/b&gt;Password change request: The server requires the password to be changed.
&lt;/ul&gt;</descrip>
            <iversion>9.5.0.52</iversion>
            <links2 />
            <args2 />
        </property>
        <property name="CaretControl" read="1" write="1" ax="1" cpp="1" dn="1" axId="191">
            <gType>bool</gType>
            <descrip>Controls whether the caret character '^' is interpreted as indicating a control character.  The default value of this property is _FALSE_.  If set to _TRUE_, then the following sequences are interpreted as control characters in any string passed to SendReqExec or ChannelSendString.
&lt;pre&gt;
^@ 	00 	00 	NUL  	Null
^A 	01 	01 	SOH  	Start of Heading
^B 	02 	02 	STX  	Start of Text
^C 	03 	03 	ETX  	End of Text
^D 	04 	04 	EOT  	End of Transmission
^E 	05 	05 	ENQ  	Enquiry
^F 	06 	06 	ACK  	Acknowledge
^G 	07 	07 	BEL  	Bell
^H 	08 	08 	BS  	Backspace
^I 	09 	09 	HT  	Character Tabulation, Horizontal Tabulation
^J 	10 	0A 	LF  	Line Feed
^K 	11 	0B 	VT  	Line Tabulation, Vertical Tabulation
^L 	12 	0C 	FF  	Form Feed
^M 	13 	0D 	CR  	Carriage Return
^N 	14 	0E 	SO  	Shift Out
^O 	15 	0F 	SI  	Shift In
^P 	16 	10 	DLE  	Data Link Escape
^Q 	17 	11 	DC1  	Device Control One (XON)
^R 	18 	12 	DC2  	Device Control Two
^S 	19 	13 	DC3  	Device Control Three (XOFF)
^T 	20 	14 	DC4  	Device Control Four
^U 	21 	15 	NAK  	Negative Acknowledge
^V 	22 	16 	SYN  	Synchronous Idle
^W 	23 	17 	ETB  	End of Transmission Block
^X 	24 	18 	CAN  	Cancel
^Y 	25 	19 	EM  	End of medium
^Z 	26 	1A 	SUB  	Substitute
^[ 	27 	1B 	ESC  	Escape
^\ 	28 	1C 	FS  	File Separator
^] 	29 	1D 	GS  	Group Separator
^^ 	30 	1E 	RS  	Record Separator
^_ 	31 	1F 	US  	Unit Separator
^? 	127 	7F 	DEL  	Delete
&lt;/pre&gt;</descrip>
            <iversion>9.5.0.49</iversion>
            <links2 />
            <args2 />
        </property>
        <property cpp="1" dn="1" ax="1" read="1" write="0" name="ChannelOpenFailCode" axId="100">
            <gType>int</gType>
            <descrip>If a request to open a channel fails, this property contains a code that identifies the reason for failure.  The reason codes are defined in RFC 4254 and are reproduced here:
&lt;pre&gt;
             Symbolic name                           reason code
             -------------                           -----------
            SSH_OPEN_ADMINISTRATIVELY_PROHIBITED          1
            SSH_OPEN_CONNECT_FAILED                       2
            SSH_OPEN_UNKNOWN_CHANNEL_TYPE                 3
            SSH_OPEN_RESOURCE_SHORTAGE                    4
&lt;/pre&gt;</descrip>
            <links2 />
            <args2 />
        </property>
        <property cpp="1" dn="1" ax="1" read="1" write="0" name="ChannelOpenFailReason" axId="101">
            <gType>string</gType>
            <descrip>The descriptive text corresponding to the ChannelOpenFailCode property.</descrip>
            <links2 />
            <args2 />
        </property>
        <property name="ClientIdentifier" axId="102" read="1" write="1" ax="1" cpp="1" dn="1">
            <gType>string</gType>
            <descrip>The client-identifier string to be used when connecting to an SSH/SFTP server.  Defaults to "SSH-2.0-PuTTY_Release_0.63".   (This string is used to mimic PuTTY because some servers are known to disconnect from clients with unknown client identifiers.)</descrip>
            <links2 />
            <args2 />
        </property>
        <property cpp="1" dn="1" ax="1" read="1" write="1" name="ClientIpAddress" axId="103">
            <gType>string</gType>
            <descrip>The IP address to use for computers with multiple network interfaces or IP addresses.
For computers with a single network interface (i.e. most computers), this property should not be set.  For multihoming computers, the default IP address is automatically used if this property is not set.&lt;p&gt;
The IP address is a string such as in dotted notation using numbers, not domain names, such as "165.164.55.124".</descrip>
            <links2 />
            <args2 />
        </property>
        <property cpp="1" dn="1" ax="1" read="1" write="1" name="ConnectTimeoutMs" axId="104">
            <gType>int</gType>
            <descrip>Maximum number of milliseconds to wait when connecting to an SSH server.</descrip>
            <links2 />
            <args2 />
        </property>
        <property cpp="1" dn="1" ax="1" read="1" write="0" name="DisconnectCode" axId="105">
            <gType>int</gType>
            <descrip>If the SSH server sent a DISCONNECT message when closing the connection, this property contains the "reason code" as specified in RFC 4253:
&lt;pre&gt;
           Symbolic name                                reason code
           -------------                                -----------
      SSH_DISCONNECT_HOST_NOT_ALLOWED_TO_CONNECT             1
      SSH_DISCONNECT_PROTOCOL_ERROR                          2
      SSH_DISCONNECT_KEY_EXCHANGE_FAILED                     3
      SSH_DISCONNECT_RESERVED                                4
      SSH_DISCONNECT_MAC_ERROR                               5
      SSH_DISCONNECT_COMPRESSION_ERROR                       6
      SSH_DISCONNECT_SERVICE_NOT_AVAILABLE                   7
      SSH_DISCONNECT_PROTOCOL_VERSION_NOT_SUPPORTED          8
      SSH_DISCONNECT_HOST_KEY_NOT_VERIFIABLE                 9
      SSH_DISCONNECT_CONNECTION_LOST                        10
      SSH_DISCONNECT_BY_APPLICATION                         11
      SSH_DISCONNECT_TOO_MANY_CONNECTIONS                   12
      SSH_DISCONNECT_AUTH_CANCELLED_BY_USER                 13
      SSH_DISCONNECT_NO_MORE_AUTH_METHODS_AVAILABLE         14
      SSH_DISCONNECT_ILLEGAL_USER_NAME                      15
&lt;/pre&gt;</descrip>
            <links2 />
            <args2 />
        </property>
        <property cpp="1" dn="1" ax="1" read="1" write="0" name="DisconnectReason" axId="106">
            <gType>string</gType>
            <descrip>If the SSH/ server sent a DISCONNECT message when closing the connection, this property contains a descriptive string for the "reason code" as specified in RFC 4253.</descrip>
            <links2 />
            <args2 />
        </property>
        <property name="ForceCipher" axId="107" read="1" write="1" ax="1" cpp="1" dn="1">
            <gType>string</gType>
            <descrip>Set to one of the following encryption algorithms to force that cipher to be used.  By default, the component will automatically choose the first cipher supported by the server in the order listed here:  "aes256-ctr", "aes128-ctr", "aes256-cbc", "aes128-cbc", "twofish256-cbc", "twofish128-cbc", "blowfish-cbc", "3des-cbc", "arcfour128", "arcfour256".   (If blowfish is chosen, the encryption strength is 128 bits.)     
&lt;p&gt;
Important: If this is property is set and the server does NOT support then encryption algorithm, then the Connect will fail.</descrip>
            <links2 />
            <args2 />
        </property>
        <property cpp="1" dn="1" ax="1" read="1" write="1" name="HeartbeatMs" axId="108">
            <gType>int</gType>
            <descrip>This is the number of milliseconds between each AbortCheck event callback.  The AbortCheck callback allows an application to abort any SSH operation prior to completion.  If HeartbeatMs is 0 (the default), no AbortCheck event callbacks will fire.</descrip>
            <links>
                <link>
                    <text>HeartbeatMs and the AbortCheck Event</text>
                    <url_cs>http://www.cknotes.com/?p=149</url_cs>
                    <url_vb.net>http://www.cknotes.com/?p=149</url_vb.net>
                </link>
            </links>
            <links2>
                <link linkType="external" lang="csharp">
                    <text>HeartbeatMs and the AbortCheck Event</text>
                    <url>http://www.cknotes.com/?p=149</url>
                </link>
            </links2>
            <args2 />
        </property>
        <property name="HostKeyAlg" axId="109" read="1" write="1" ax="1" cpp="1" dn="1">
            <gType>string</gType>
            <descrip>Indicates the preferred host key algorithm to be used in establishing the SSH secure connection.  The default is "DSS".  It may be changed to "RSA" if needed.  Chilkat recommends not changing this unless a problem warrants the change.</descrip>
            <links2 />
            <args2 />
        </property>
        <property cpp="1" dn="1" ax="1" read="1" write="0" name="HostKeyFingerprint" axId="110">
            <gType>string</gType>
            <descrip>Set after connecting to an SSH server.  The format of the fingerprint looks like this:  "ssh-rsa 1024 68:ff:d1:4e:6c:ff:d7:b0:d6:58:73:85:07:bc:2e:d5"</descrip>
            <links2 />
            <args2 />
        </property>
        <property cpp="1" dn="1" ax="1" read="1" write="1" name="HttpProxyAuthMethod" axId="111">
            <gType>string</gType>
            <descrip>If an HTTP proxy requiring authentication is to be used, set this property to the HTTP proxy authentication method name.  Valid choices are "Basic" or "NTLM".</descrip>
            <links2 />
            <args2 />
        </property>
        <property cpp="1" dn="1" ax="1" read="1" write="1" name="HttpProxyDomain" axId="112">
            <gType>string</gType>
            <descrip>The NTLM authentication domain (optional) if NTLM authentication is used w/ the HTTP proxy.</descrip>
            <links2 />
            <args2 />
        </property>
        <property name="HttpProxyHostname" axId="113" read="1" write="1" ax="1" cpp="1" dn="1">
            <gType>string</gType>
            <descrip>If an HTTP proxy is to be used, set this property to the HTTP proxy hostname or IPv4 address (in dotted decimal notation).</descrip>
            <links2>
                <link linkType="example">
                    <url>ssh_http_proxy.asp</url>
                    <text>SSH using HTTP Proxy</text>
                </link>
            </links2>
            <args2 />
        </property>
        <property cpp="1" dn="1" ax="1" read="1" write="1" name="HttpProxyPassword" axId="114">
            <gType>string</gType>
            <descrip>If an HTTP proxy requiring authentication is to be used, set this property to the HTTP proxy password.</descrip>
            <links2 />
            <args2 />
        </property>
        <property cpp="1" dn="1" ax="1" read="1" write="1" name="HttpProxyPort" axId="115">
            <gType>int</gType>
            <descrip>If an HTTP proxy is to be used, set this property to the HTTP proxy port number.  (Two commonly used HTTP proxy ports are 8080 and 3128.)</descrip>
            <links2 />
            <args2 />
        </property>
        <property cpp="1" dn="1" ax="1" read="1" write="1" name="HttpProxyUsername" axId="116">
            <gType>string</gType>
            <descrip>If an HTTP proxy requiring authentication is to be used, set this property to the HTTP proxy login name.</descrip>
            <links2>
                <link linkType="example">
                    <url>ssh_http_proxy.asp</url>
                    <text>SSH using HTTP Proxy</text>
                </link>
            </links2>
            <args2 />
        </property>
        <property cpp="1" dn="1" ax="1" read="1" write="1" name="IdleTimeoutMs" axId="117">
            <gType>int</gType>
            <descrip>Causes SSH operations to fail when progress for sending or receiving data halts for more than this number of milliseconds.  Setting IdleTimeoutMs = 0 (the default) allows the application to wait indefinitely.</descrip>
            <links2 />
            <args2 />
        </property>
        <property write="0" name="IsConnected" axId="118" read="1" ax="1" cpp="1" dn="1">
            <gType>bool</gType>
            <descrip>Returns _TRUE_ if the component is connected to an SSH server.  
&lt;p&gt;
Note: The IsConnected property is set to _TRUE_ after successfully completing the Connect method call.  The IsConnected property will only be set to _FALSE_ by calling Disconnect, or by the failure of another method call such that the disconnection is detected.</descrip>
            <links2 />
            <args2 />
        </property>
        <property cpp="1" dn="1" ax="1" read="1" write="1" name="KeepSessionLog" axId="119">
            <gType>bool</gType>
            <descrip>Controls whether communications to/from the SSH server are saved to the SessionLog property.  The default value is _FALSE_.   If this property is set to _TRUE_, the contents of the SessionLog property will continuously grow as SSH activity transpires.   The purpose of the KeepSessionLog / SessionLog properties is to help in debugging any future problems that may arise.</descrip>
            <links2 />
            <args2 />
        </property>
        <property name="MaxPacketSize" axId="120" read="1" write="1" ax="1" cpp="1" dn="1">
            <gType>int</gType>
            <descrip>The maximum packet length to be used in the  SSH transport protocol.  The default value is 8192. 
&lt;p&gt;
Note: If a large amount of data is to be flowing to/from the SSH server, then setting the MaxPacketSize equal to 32768 may improve performance. For those familiar with the inner workings of the SSH protocol, this is the "maximum packet size" value that is sent in the SSH_MSG_CHANNEL_OPEN message as defined in RFC 4254.</descrip>
            <links2 />
            <args2 />
        </property>
        <property cpp="1" dn="1" ax="1" read="1" write="0" name="NumOpenChannels" axId="121">
            <gType>int</gType>
            <descrip>The number of currently open channels.</descrip>
            <links2 />
            <args2 />
        </property>
        <property cpp="1" dn="1" ax="1" read="1" write="0" name="PasswordChangeRequested" axId="122">
            <gType>bool</gType>
            <descrip>Set by the AuthenticatePw and AuthenticatePwPk methods.  If the authenticate  method returns a failed status, and this property is set to _TRUE_, then it indicates the server requested a password change.  In this case, re-call the authenticate method, but provide both the old and new passwords in the following format, where vertical bar characters encapsulate the old and new passwords:  
&lt;p&gt;&lt;blockquote&gt;|oldPassword|newPassword|&lt;/blockquote&gt;&lt;/p&gt;</descrip>
            <links2 />
            <args2 />
        </property>
        <property name="PreferIpv6" read="1" write="1" ax="1" cpp="1" dn="1" axId="181">
            <gType>bool</gType>
            <descrip>If _TRUE_, then use IPv6 over IPv4 when both are supported for a particular domain.   The default value of this property is _FALSE_, which will choose IPv4 over IPv6.</descrip>
            <links2 />
            <args2 />
        </property>
        <property cpp="1" dn="1" ax="1" read="1" write="1" name="ReadTimeoutMs" axId="123">
            <gType>int</gType>
            <descrip>The maximum amount of time to allow for reading messages/data from the SSH server.   This is different from the IdleTimeoutMs property.  The IdleTimeoutMs is the maximum amount of time to wait while no incoming data is arriving.   The ReadTimeoutMs is the maximum amount of time to allow for reading data even if data is continuing to arrive.  The default value of 0 indicates an infinite timeout value.</descrip>
            <links2 />
            <args2 />
        </property>
        <property name="ReqExecCharset" read="1" write="1" ax="1" cpp="1" dn="1" axId="187">
            <gType>string</gType>
            <descrip>Indicates the charset to be used for the command sent via the SendReqExec method.  The default is "ANSI".  A likely alternate value would be "utf-8".</descrip>
            <iversion>9.5.0.47</iversion>
            <links2 />
            <args2 />
        </property>
        <property cpp="1" dn="1" ax="1" read="1" write="0" name="SessionLog" axId="124">
            <gType>string</gType>
            <descrip>Contains a log of the messages sent to/from the SSH server.  To enable session logging, set the KeepSessionLog property = _TRUE_.  Note: This property is not a filename -- it is a string property that contains the session log data.</descrip>
            <links2 />
            <args2 />
        </property>
        <property cpp="1" dn="1" ax="1" read="1" write="1" name="SoRcvBuf" axId="125">
            <gType>int</gType>
            <descrip>Sets the receive buffer size socket option.   Normally, this property should be left unchanged.  The default value is 0, which indicates that the receive buffer size socket option should not be explicitly set (i.e. the system default value, which may vary from system to system, should be used).   
&lt;p&gt;
This property can be changed if download performance seems slow.  It is recommended to be a multiple of 4096.  To see the current system's default receive buffer size, examine the LastErrorText property after calling any method that establishes a connection.  It should be reported under the heading "SO_RCVBUF".  To boost performance, try setting it equal to 2, 3, or 4 times the default value.</descrip>
            <links>
                <link>
                    <text>More Information about TCP performance and Buffer Sizes</text>
                    <url>http://www.cknotes.com/?p=446</url>
                </link>
            </links>
            <links2>
                <link linkType="external">
                    <text>More Information about TCP performance and Buffer Sizes</text>
                    <url>http://www.cknotes.com/?p=446</url>
                </link>
            </links2>
            <args2 />
        </property>
        <property cpp="1" dn="1" ax="1" read="1" write="1" name="SoSndBuf" axId="126">
            <gType>int</gType>
            <descrip>Sets the send buffer size socket option.   Normally, this property should be left unchanged.  The default value is 0, which indicates that the send buffer size socket option should not be explicitly set (i.e. the system default value, which may vary from system to system, should be used).   
&lt;p&gt;
This property can be changed if upload performance seems slow.  It is recommended to be a multiple of 4096.  To see the current system's default send buffer size, examine the LastErrorText property after calling any method that establishes a connection.  It should be reported under the heading "SO_SNDBUF".  To boost performance, try setting it equal to 2, 3, or 4 times the default value.</descrip>
            <links>
                <link>
                    <text>More Information about TCP performance and Buffer Sizes</text>
                    <url>http://www.cknotes.com/?p=446</url>
                </link>
            </links>
            <links2>
                <link linkType="external">
                    <text>More Information about TCP performance and Buffer Sizes</text>
                    <url>http://www.cknotes.com/?p=446</url>
                </link>
            </links2>
            <args2 />
        </property>
        <property cpp="1" dn="1" ax="1" read="1" write="1" name="SocksHostname" axId="127">
            <gType>string</gType>
            <descrip>The SOCKS4/SOCKS5 hostname or IPv4 address (in dotted decimal notation).  This property is only used if the SocksVersion property is set to 4 or 5).</descrip>
            <links2 />
            <args2 />
        </property>
        <property cpp="1" dn="1" ax="1" read="1" write="1" name="SocksPassword" axId="128">
            <gType>string</gType>
            <descrip>The SOCKS5 password (if required).  The SOCKS4 protocol does not include the use of a password, so this does not apply to SOCKS4.</descrip>
            <links2 />
            <args2 />
        </property>
        <property cpp="1" dn="1" ax="1" read="1" write="1" name="SocksPort" axId="129">
            <gType>int</gType>
            <descrip>The SOCKS4/SOCKS5 proxy port.  The default value is 1080. 
This property only applies if a SOCKS proxy is used (if the SocksVersion property is set to 4 or 5).</descrip>
            <links2 />
            <args2 />
        </property>
        <property cpp="1" dn="1" ax="1" read="1" write="1" name="SocksUsername" axId="130">
            <gType>string</gType>
            <descrip>The SOCKS4/SOCKS5 proxy username.  This property is only used if the SocksVersion property is set to 4 or 5).</descrip>
            <links2 />
            <args2 />
        </property>
        <property cpp="1" dn="1" ax="1" read="1" write="1" name="SocksVersion" axId="131">
            <gType>int</gType>
            <descrip>SocksVersion
May be set to one of the following integer values:
&lt;p&gt;
&lt;b&gt;0&lt;/b&gt; - No SOCKS proxy is used.  This is the default.&lt;br&gt;
&lt;b&gt;4&lt;/b&gt; - Connect via a SOCKS4 proxy.&lt;br&gt;
&lt;b&gt;5&lt;/b&gt; - Connect via a SOCKS5 proxy.</descrip>
            <links2 />
            <args2 />
        </property>
        <property cpp="1" dn="1" ax="1" read="1" write="1" name="StderrToStdout" axId="132">
            <gType>bool</gType>
            <descrip>If _TRUE_, then stderr is redirected to stdout.  In this case,  channel output for both stdout and stderr is combined and retrievable via the following methods:  GetReceivedData, GetReceivedDataN, GetReceivedText, GetReceivedTextS.   If this property is _FALSE_, then stderr is available separately via the GetReceivedStderr method.
&lt;p&gt;
The default value of this property is _TRUE_.
&lt;p&gt;
Note: Most SSH servers do not send stderr output as "extended data" packets as specified in RFC 4254.   The SessionLog may be examined to see if any CHANNEL_EXTENDED_DATA messages exist.  If not, then all of the output (stdout + stderr) was sent via CHANNEL_DATA messages, and therefore it is not possible to differentiate stderr output from stdout.   In summary:  This feature will not work for most SSH servers.</descrip>
            <links2 />
            <args2 />
        </property>
        <property name="TcpNoDelay" axId="133" read="1" write="1" ax="1" cpp="1" dn="1">
            <gType>bool</gType>
            <descrip>Controls whether the TCP_NODELAY socket option is used for the underlying TCP/IP socket.  The default value is _TRUE_.  This disables the Nagle algorithm and allows for better performance when small amounts of data are sent to/from the SSH server.</descrip>
            <links2 />
            <args2 />
        </property>
        <property name="UserAuthBanner" read="1" write="1" ax="1" cpp="1" dn="1" axId="185">
            <gType>string</gType>
            <descrip>If a user authentication banner message is received during authentication, it will be made available here.  An application can check to see if this property contains a banner string after calling StartKeyboardAuth.  It is only possible for an application to display this message if it is doing keyboard-interactive authentication via the StartKeyboardAuth and ContinueKeyboardAuth methods.</descrip>
            <iversion>9.5.0.46</iversion>
            <links2 />
            <args2 />
        </property>
        <property name="EnableCompression" read="1" write="1" ax="1" cpp="1" dn="1" axId="194">
            <gType>bool</gType>
            <descrip>Enables or disables the use of compression w/ the SSH connection.  The default value is  _TRUE_, meaning that compression is used if the server supports it.
&lt;p&gt;
Some older SSH servers have been found that claim to support compression, but actually fail when compression is used.  PuTTY does not enable compression by default.  If trouble is encountered where the SSH server disconnects immediately after the connection is seemingly established (i.e. during authentication), then check to see if disabling compression resolves the problem.</descrip>
            <iversion>9.5.0.56</iversion>
            <links2 />
            <args2 />
        </property>
        <property name="AbortCurrent" read="1" write="1" ax="1" cpp="1" dn="1" axId="195">
            <gType>bool</gType>
            <descrip>When set to _TRUE_, causes the currently running method to abort.  Methods that always finish quickly (i.e.have no length file operations or network communications) are not affected.  If no method is running, then this property is automatically reset to _FALSE_ when the next method is called.  When the abort occurs, this property is reset to _FALSE_.  Both synchronous and asynchronous method calls can be aborted.  (A synchronous method call could be aborted by setting this property from a separate thread.)</descrip>
            <iversion>9.5.0.58</iversion>
            <links2 />
            <args2 />
        </property>
    </properties>
    <methods>
        <method name="AuthenticatePk" axId="134" ax="1" cpp="1" dn="1" events="1" status="1">
            <gType>bool</gType>
            <args>
                <arg>
                    <axType>string</axType>
                    <dnType>string</dnType>
                    <cppType>const char *</cppType>
                    <argName>username</argName>
                    <objcName>username</objcName>
                </arg>
                <arg>
                    <axType>SshKey</axType>
                    <dnType>SshKey</dnType>
                    <cppType>CkSshKey &amp;</cppType>
                    <argName>privateKey</argName>
                    <objcName>privateKey</objcName>
                </arg>
            </args>
            <descrip>Authenticates with the SSH server using public-key authentication.  The corresponding public key must have been installed on the SSH server for the ARG1.   Authentication will succeed if the matching ARG2 is provided.
&lt;p&gt;
Important: When reporting problems, please send the full contents of the LastErrorText property to support@chilkatsoft.com.</descrip>
            <links2>
                <link linkType="external">
                    <text>Beware of too much time between connect and authentication.</text>
                    <url>http://www.cknotes.com/?p=278</url>
                </link>
                <link linkType="example">
                    <url>ssh_use_ppk_putty_private_key.asp</url>
                    <text>Use PuTTY Key for SSH Authentication</text>
                </link>
            </links2>
            <args2>
                <arg name="username" type="string" objcName="username" />
                <arg name="privateKey" type="SshKey" objcName="privateKey" />
            </args2>
        </method>
        <method name="AuthenticatePw" axId="135" ax="1" cpp="1" dn="1" events="1" status="1">
            <gType>bool</gType>
            <args>
                <arg>
                    <axType>string</axType>
                    <dnType>string</dnType>
                    <cppType>const char *</cppType>
                    <argName>login</argName>
                    <objcName>login</objcName>
                </arg>
                <arg>
                    <axType>string</axType>
                    <dnType>string</dnType>
                    <cppType>const char *</cppType>
                    <argName>password</argName>
                    <objcName>password</objcName>
                </arg>
            </args>
            <descrip>Authenticates with the SSH server using a ARG1 and ARG2.
&lt;p&gt;
An SSH session always begins by first calling Connect to connect to the SSH server, and then calling either AuthenticatePw or AuthenticatePk to login.
&lt;p&gt;
Important: When reporting problems, please send the full contents of the LastErrorText property to support@chilkatsoft.com.
&lt;br&gt;
Note: To learn about how to handle password change requests, see the PasswordChangeRequested property (above).</descrip>
            <links2>
                <link linkType="external">
                    <text>Beware of too much time between connect and authentication.</text>
                    <url>http://www.cknotes.com/?p=278</url>
                </link>
            </links2>
            <args2>
                <arg name="login" type="string" objcName="login" />
                <arg name="password" type="string" objcName="password" />
            </args2>
        </method>
        <method cpp="1" dn="1" ax="1" events="1" status="1" name="AuthenticatePwPk" axId="136">
            <gType>bool</gType>
            <args>
                <arg>
                    <axType>string</axType>
                    <dnType>string</dnType>
                    <cppType>const char *</cppType>
                    <argName>username</argName>
                    <objcName>username</objcName>
                </arg>
                <arg>
                    <axType>string</axType>
                    <dnType>string</dnType>
                    <cppType>const char *</cppType>
                    <argName>password</argName>
                    <objcName>password</objcName>
                </arg>
                <arg>
                    <axType>SshKey</axType>
                    <dnType>SshKey</dnType>
                    <cppType>CkSshKey &amp;</cppType>
                    <argName>privateKey</argName>
                    <objcName>privateKey</objcName>
                </arg>
            </args>
            <descrip>Authentication for SSH servers that require both a password and private key.  (Most SSH servers are configured to require one or the other, but not both.)
&lt;p&gt;
Important: When reporting problems, please send the full contents of the LastErrorText property to support@chilkatsoft.com.</descrip>
            <args2>
                <arg name="username" type="string" objcName="username" />
                <arg name="password" type="string" objcName="password" />
                <arg name="privateKey" type="SshKey" objcName="privateKey" />
            </args2>
            <links2 />
        </method>
        <method cpp="1" dn="1" ax="1" name="ChannelIsOpen" axId="137">
            <gType>bool</gType>
            <args>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>channelNum</argName>
                    <objcName>channelNum</objcName>
                </arg>
            </args>
            <descrip>Returns _TRUE_ if the channel indicated by ARG1 is open.  Otherwise returns _FALSE_.</descrip>
            <args2>
                <arg name="channelNum" type="int" objcName="channelNum" />
            </args2>
            <links2 />
        </method>
        <method name="ChannelPoll" axId="138" ax="1" cpp="1" dn="1" events="1">
            <gType>int</gType>
            <args>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>channelNum</argName>
                    <objcName>channelNum</objcName>
                </arg>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>pollTimeoutMs</argName>
                    <objcName>pollTimeoutMs</objcName>
                </arg>
            </args>
            <descrip>Polls for incoming data on an open channel.  This method will read a channel, waiting at most ARG2 milliseconds for data to arrive.  Return values are as follows:
&lt;p&gt;
&lt;b&gt;-1&lt;/b&gt; -- Error.  Check the IsConnected property to see if the connection to the SSH server is still valid.  
       Also, call ChannelIsOpen to see if the channel remains open.  The LastErrorText property will contain 
       more detailed information regarding the error.
&lt;p&gt;
&lt;b&gt;-2&lt;/b&gt; -- No additional data was received prior to the poll timeout.
&lt;p&gt;
&lt;b&gt;&gt;0&lt;/b&gt; -- Additional data was received and the return value indicates how many bytes are available to be "picked up".  Methods that read data on a channel do not return the received data directly.  Instead, they return an integer
to indicate how many bytes are available to be "picked up".  An application picks up the available data by calling
GetReceivedData or GetReceivedText.
&lt;p&gt;
&lt;b&gt;=0&lt;/b&gt; -- A zero can be returned if the channel EOF has already been received, or if the channel had already been closed.</descrip>
            <args2>
                <arg name="channelNum" type="int" objcName="channelNum" />
                <arg name="pollTimeoutMs" type="int" objcName="pollTimeoutMs" />
            </args2>
            <links2 />
        </method>
        <method name="ChannelRead" axId="139" ax="1" cpp="1" dn="1" events="1">
            <gType>int</gType>
            <args>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>channelNum</argName>
                    <objcName>channelNum</objcName>
                </arg>
            </args>
            <descrip>Reads incoming data on an open channel.  This method will read a channel, waiting at most IdleTimeoutMs milliseconds for data to arrive.  Return values are as follows:
&lt;p&gt;
&lt;b&gt;-1&lt;/b&gt; -- Error.  Check the IsConnected property to see if the connection to the SSH server is still valid.  
       Also, call ChannelIsOpen to see if the channel remains open.  The LastErrorText property will contain 
       more detailed information regarding the error.
&lt;p&gt;
&lt;b&gt;-2&lt;/b&gt; -- No additional data was received prior to the IdleTimeoutMs timeout.
&lt;p&gt;
&lt;b&gt;&gt;0&lt;/b&gt; -- Additional data was received and the return value indicates how many bytes are available to be "picked up".  Methods that read data on a channel do not return the received data directly.  Instead, they return an integer
to indicate how many bytes are available to be "picked up".  An application picks up the available data by calling
GetReceivedData or GetReceivedText.
&lt;p&gt;
&lt;b&gt;=0&lt;/b&gt; -- A zero can be returned if the channel EOF has already been received, or if the channel had already been closed.</descrip>
            <args2>
                <arg name="channelNum" type="int" objcName="channelNum" />
            </args2>
            <links2 />
        </method>
        <method name="ChannelReadAndPoll" axId="140" ax="1" cpp="1" dn="1" events="1">
            <gType>int</gType>
            <args>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>channelNum</argName>
                    <objcName>channelNum</objcName>
                </arg>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>pollTimeoutMs</argName>
                    <objcName>pollTimeoutMs</objcName>
                </arg>
            </args>
            <descrip>Reads incoming data on an open channel and  continues reading until no data arrives for ARG2 milliseconds.    The first read will wait a max of IdleTimeoutMs milliseconds before timing out.  Subsequent reads wait a max of ARG2 milliseconds before timing out.  
&lt;p&gt;
The idea behind ChannelReadAndPoll is to capture the output of a shell command.  One might imagine the typical sequence of events when executing a shell command to be like this:  (1) client sends command to server, (2) server executes the command (i.e. it's computing...), potentially taking some amount of time, (3) output is streamed back to the client.   It makes sense for the client to wait a longer period of time for the first data to arrive, but once it begins arriving, the timeout can be shortened.  This is exactly what ChannelReadAndPoll does -- the first timeout is controlled by the IdleTimeoutMs property, while the subsequent reads (once output starts flowing) is controlled by ARG2.
&lt;p&gt;
Return values are as follows:&lt;br&gt;
&lt;b&gt;-1&lt;/b&gt; -- Error.  Check the IsConnected property to see if the connection to the SSH server is still valid.  
       Also, call ChannelIsOpen to see if the channel remains open.  The LastErrorText property will contain 
       more detailed information regarding the error.
&lt;p&gt;
&lt;b&gt;-2&lt;/b&gt; -- No additional data was received prior to the IdleTimeoutMs timeout.
&lt;p&gt;
&lt;b&gt;&gt;0&lt;/b&gt; -- Additional data was received and the return value indicates how many bytes are available to be "picked up".  Methods that read data on a channel do not return the received data directly.  Instead, they return an integer
to indicate how many bytes are available to be "picked up".  An application picks up the available data by calling
GetReceivedData or GetReceivedText.
&lt;p&gt;
&lt;b&gt;=0&lt;/b&gt; -- A zero can be returned if the channel EOF has already been received, or if the channel had already been closed.</descrip>
            <args2>
                <arg name="channelNum" type="int" objcName="channelNum" />
                <arg name="pollTimeoutMs" type="int" objcName="pollTimeoutMs" />
            </args2>
            <links2 />
        </method>
        <method name="ChannelReadAndPoll2" axId="141" ax="1" cpp="1" dn="1" events="1">
            <gType>int</gType>
            <args>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>channelNum</argName>
                    <objcName>channelNum</objcName>
                </arg>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>pollTimeoutMs</argName>
                    <objcName>pollTimeoutMs</objcName>
                </arg>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>maxNumBytes</argName>
                    <objcName>maxNumBytes</objcName>
                </arg>
            </args>
            <descrip>The same as ChannelReadAndPoll, except this method will return as soon as ARG3 is exceeded, which may be as large as the MaxPacketSize property setting.</descrip>
            <args2>
                <arg name="channelNum" type="int" objcName="channelNum" />
                <arg name="pollTimeoutMs" type="int" objcName="pollTimeoutMs" />
                <arg name="maxNumBytes" type="int" objcName="maxNumBytes" />
            </args2>
            <links2 />
        </method>
        <method cpp="1" dn="1" ax="1" events="1" status="1" name="ChannelReceiveToClose" axId="142">
            <gType>bool</gType>
            <args>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>channelNum</argName>
                    <objcName>channelNum</objcName>
                </arg>
            </args>
            <descrip>Reads incoming data on an open channel until the channel is closed by the server.   If successful, the number of bytes available to be "picked up" can be determined by calling GetReceivedNumBytes.  The received data may be retrieved by calling GetReceivedData or GetReceivedText.</descrip>
            <args2>
                <arg name="channelNum" type="int" objcName="channelNum" />
            </args2>
            <links2 />
        </method>
        <method cpp="1" dn="1" ax="1" events="1" status="1" name="ChannelReceiveUntilMatch" axId="143">
            <gType>bool</gType>
            <args>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>channelNum</argName>
                    <objcName>channelNum</objcName>
                </arg>
                <arg>
                    <axType>string</axType>
                    <dnType>string</dnType>
                    <cppType>const char *</cppType>
                    <argName>matchPattern</argName>
                    <objcName>matchPattern</objcName>
                </arg>
                <arg>
                    <axType>string</axType>
                    <dnType>string</dnType>
                    <cppType>const char *</cppType>
                    <argName>charset</argName>
                    <objcName>charset</objcName>
                </arg>
                <arg>
                    <axType>bool</axType>
                    <dnType>bool</dnType>
                    <cppType>bool</cppType>
                    <argName>caseSensitive</argName>
                    <objcName>caseSensitive</objcName>
                </arg>
            </args>
            <descrip>Reads incoming text data on an open channel until the received data matches the ARG2.   For example, to receive data until the string "Hello World" arrives, set ARG2 equal to "*Hello World*".   ARG3 indicates the character encoding of the text being received ("iso-8859-1" for example).  ARG4 may be set to _TRUE_ for case sensitive matching, or _FALSE_ for case insensitive matching. 
&lt;p&gt;
Returns _TRUE_ if text data matching ARG2 was received and is available to be picked up by calling GetReceivedText (or GetReceivedTextS).    &lt;b&gt;IMPORTANT:&lt;/b&gt; This method may read beyond the matching text.  Call GetReceivedTextS to extract only the data up-to and including the matching text.</descrip>
            <args2>
                <arg name="channelNum" type="int" objcName="channelNum" />
                <arg name="matchPattern" type="string" objcName="matchPattern" />
                <arg name="charset" type="string" objcName="charset" />
                <arg name="caseSensitive" type="bool" objcName="caseSensitive" />
            </args2>
            <links2 />
        </method>
        <method name="ChannelReceiveUntilMatchN" axId="144" ax="1" cpp="1" dn="1" events="1" status="1">
            <gType>bool</gType>
            <args>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>channelNum</argName>
                    <objcName>channelNum</objcName>
                </arg>
                <arg>
                    <axType>StringArray</axType>
                    <dnType>StringArray</dnType>
                    <cppType>CkStringArray &amp;</cppType>
                    <argName>matchPatterns</argName>
                    <objcName>matchPatterns</objcName>
                </arg>
                <arg>
                    <axType>string</axType>
                    <dnType>string</dnType>
                    <cppType>const char *</cppType>
                    <argName>charset</argName>
                    <objcName>charset</objcName>
                </arg>
                <arg>
                    <axType>bool</axType>
                    <dnType>bool</dnType>
                    <cppType>bool</cppType>
                    <argName>caseSensitive</argName>
                    <objcName>caseSensitive</objcName>
                </arg>
            </args>
            <descrip>The same as ChannelReceiveUntilMatch except that the method returns when any one of the match patterns specified in ARG2 are received on the channel.</descrip>
            <links2>
                <link linkType="example">
                    <url>ssh_receiveUntilMatchN.asp</url>
                    <text>SSH ReceiveUntilMatchN</text>
                </link>
            </links2>
            <args2>
                <arg name="channelNum" type="int" objcName="channelNum" />
                <arg name="matchPatterns" type="StringArray" objcName="matchPatterns" />
                <arg name="charset" type="string" objcName="charset" />
                <arg name="caseSensitive" type="bool" objcName="caseSensitive" />
            </args2>
        </method>
        <method cpp="1" dn="1" ax="1" name="ChannelReceivedClose" axId="145">
            <gType>bool</gType>
            <args>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>channelNum</argName>
                    <objcName>channelNum</objcName>
                </arg>
            </args>
            <descrip>_TRUE_ if a CLOSE message has been received on the channel indicated by ARG1.   When a CLOSE is received, no subsequent data should be sent in either direction -- the channel is closed in both directions.</descrip>
            <args2>
                <arg name="channelNum" type="int" objcName="channelNum" />
            </args2>
            <links2 />
        </method>
        <method cpp="1" dn="1" ax="1" name="ChannelReceivedEof" axId="146">
            <gType>bool</gType>
            <args>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>channelNum</argName>
                    <objcName>channelNum</objcName>
                </arg>
            </args>
            <descrip>_TRUE_ if an EOF message has been received on the channel indicated by ARG1.  When an EOF is received, no more data will be forthcoming on the channel.  However, data may still be sent in the opposite direction.</descrip>
            <args2>
                <arg name="channelNum" type="int" objcName="channelNum" />
            </args2>
            <links2 />
        </method>
        <method cpp="1" dn="1" ax="1" name="ChannelReceivedExitStatus" axId="147">
            <gType>bool</gType>
            <args>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>channelNum</argName>
                    <objcName>channelNum</objcName>
                </arg>
            </args>
            <descrip>_TRUE_ if an exit status code was received on the channel.  Otherwise _FALSE_.</descrip>
            <args2>
                <arg name="channelNum" type="int" objcName="channelNum" />
            </args2>
            <links2 />
        </method>
        <method name="ChannelRelease" ax="1" cpp="1" dn="1" axId="182">
            <gType>void</gType>
            <descrip>Releases the internal memory resources for a channel previously opened by OpenSessionChannel, OpenCustomChannel, or OpenDirectTcpIpChannel.  It is not absolutely necessary to call this method because the internal memory resources for all channels are automatically released when the SSH object instance is deleted/disposed.  This method becomes necessary only when an extremely large number of channels within the same SSH object instance are opened, used, and closed over a long period of time.</descrip>
            <args>
                <arg>
                    <argName>channelNum</argName>
                    <cppType>int</cppType>
                    <dnType>int</dnType>
                    <axType>int</axType>
                    <objcName>channelNum</objcName>
                </arg>
            </args>
            <iversion>9.5.0.44</iversion>
            <args2>
                <arg name="channelNum" type="int" objcName="channelNum" />
            </args2>
            <links2 />
        </method>
        <method name="ChannelSendClose" axId="148" ax="1" cpp="1" dn="1" events="1" status="1">
            <gType>bool</gType>
            <args>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>channelNum</argName>
                    <objcName>channelNum</objcName>
                </arg>
            </args>
            <descrip>Sends a CLOSE message to the server for the channel indicated by ARG1.  This closes both directions of the bidirectional channel.</descrip>
            <args2>
                <arg name="channelNum" type="int" objcName="channelNum" />
            </args2>
            <links2 />
        </method>
        <method cpp="1" dn="1" ax="1" events="1" status="1" name="ChannelSendData" axId="149">
            <gType>bool</gType>
            <args>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>channelNum</argName>
                    <objcName>channelNum</objcName>
                </arg>
                <arg>
                    <axType>bytes</axType>
                    <dnType>bytes</dnType>
                    <cppType>CkByteData &amp;</cppType>
                    <argName>byteData</argName>
                    <objcName>data</objcName>
                </arg>
            </args>
            <descrip>Sends byte data on the channel indicated by ARG1.</descrip>
            <args2>
                <arg name="channelNum" type="int" objcName="channelNum" />
                <arg name="byteData" type="bytes" objcName="data" />
            </args2>
            <links2 />
        </method>
        <method name="ChannelSendEof" axId="150" ax="1" cpp="1" dn="1" events="1" status="1">
            <gType>bool</gType>
            <args>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>channelNum</argName>
                    <objcName>channelNum</objcName>
                </arg>
            </args>
            <descrip>Sends an EOF for the channel indicated by ARG1.  Once an EOF is sent, no additional data may be sent on the channel.  However, the channel remains open and additional data may still be received from the server.</descrip>
            <args2>
                <arg name="channelNum" type="int" objcName="channelNum" />
            </args2>
            <links2 />
        </method>
        <method cpp="1" dn="1" ax="1" events="1" status="1" name="ChannelSendString" axId="151">
            <gType>bool</gType>
            <args>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>channelNum</argName>
                    <objcName>channelNum</objcName>
                </arg>
                <arg>
                    <axType>string</axType>
                    <dnType>string</dnType>
                    <cppType>const char *</cppType>
                    <argName>textData</argName>
                    <objcName>strData</objcName>
                </arg>
                <arg>
                    <axType>string</axType>
                    <dnType>string</dnType>
                    <cppType>const char *</cppType>
                    <argName>charset</argName>
                    <objcName>charset</objcName>
                </arg>
            </args>
            <descrip>Sends character data on the channel indicated by ARG1.  The text is converted to the charset indicated by ARG3 prior to being sent.  A list of supported charset values may be found on this page: &lt;a href="http://www.chilkatsoft.com/p/p_463.asp"&gt;Supported Charsets&lt;/a&gt;.</descrip>
            <args2>
                <arg name="channelNum" type="int" objcName="channelNum" />
                <arg name="textData" type="string" objcName="strData" />
                <arg name="charset" type="string" objcName="charset" />
            </args2>
            <links2 />
        </method>
        <method name="CheckConnection" ax="1" cpp="1" dn="1" axId="183">
            <gType>bool</gType>
            <descrip>Returns _TRUE_  if the underlying TCP socket is connected to the SSH  server.</descrip>
            <iversion>9.5.0.46</iversion>
            <args />
            <args2 />
            <links2 />
        </method>
        <method cpp="1" dn="1" ax="1" name="ClearTtyModes" axId="152">
            <gType>void</gType>
            <args />
            <descrip>Clears the collection of TTY modes that are sent with the SendReqPty method.</descrip>
            <args2 />
            <links2 />
        </method>
        <method name="Connect" axId="153" ax="1" cpp="1" dn="1" events="1" status="1">
            <gType>bool</gType>
            <args>
                <arg>
                    <axType>string</axType>
                    <dnType>string</dnType>
                    <cppType>const char *</cppType>
                    <argName>domainName</argName>
                    <objcName>hostname</objcName>
                </arg>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>port</argName>
                    <objcName>port</objcName>
                </arg>
            </args>
            <descrip>Connects to the SSH server at ARG1:ARG2
&lt;p&gt;
The ARG1 may be a domain name or an IPv4 or IPv6 address in string format.
&lt;p&gt;
&lt;b&gt;Important: &lt;/b&gt; All TCP-based Internet communications, regardless of the protocol (such as HTTP, FTP, SSH, IMAP, POP3, SMTP, etc.), and regardless of SSL/TLS, begin with establishing a TCP connection to a remote host:port.  External security-related infrastructure such as software firewalls (Windows Firewall), hardware firewalls, anti-virus, at either source or destination (or both) can block the connection.  If the connection fails, make sure to check all potential external causes of blockage.</descrip>
            <args2>
                <arg name="domainName" type="string" objcName="hostname" />
                <arg name="port" type="int" objcName="port" />
            </args2>
            <links2 />
        </method>
        <method name="ConnectThroughSsh" ax="1" cpp="1" dn="1" events="1" status="1" axId="193">
            <gType>bool</gType>
            <descrip>Connects to an SSH  server through an existing SSH connection.  The ARG1 is an existing connected and authenticated SSH object.   The connection to ARG2:ARG3 is made through the existing SSH connection via port-forwarding.  If successful, the connection is as follows:  application =&gt; ServerSSH1 =&gt; ServerSSH2.  (where ServerSSH1 is the ARG1 and ServerSSH2 is the SSH server at ARG2:ARG3)   Once connected in this way, all communications are routed through ServerSSH1 to ServerSSH2.  This includes authentication -- which means the application must still call one of the Authenticate* methods to authenticate with ServerSSH2.</descrip>
            <args>
                <arg>
                    <argName>ssh</argName>
                    <cppType>CkSsh &amp;</cppType>
                    <dnType>Ssh</dnType>
                    <axType>Ssh</axType>
                    <objcName>ssh</objcName>
                </arg>
                <arg>
                    <argName>hostname</argName>
                    <cppType>const char *</cppType>
                    <dnType>string</dnType>
                    <axType>string</axType>
                    <objcName>hostname</objcName>
                </arg>
                <arg>
                    <argName>port</argName>
                    <cppType>int</cppType>
                    <dnType>int</dnType>
                    <axType>int</axType>
                    <objcName>port</objcName>
                </arg>
            </args>
            <iversion>9.5.0.55</iversion>
            <links2>
                <link linkType="example">
                    <url>ssh_multiHop.asp</url>
                    <text>Multi-Hop SSH (SSH Through SSH)</text>
                </link>
            </links2>
            <args2>
                <arg name="ssh" type="Ssh" objcName="ssh" />
                <arg name="hostname" type="string" objcName="hostname" />
                <arg name="port" type="int" objcName="port" />
            </args2>
        </method>
        <method name="ContinueKeyboardAuth" axId="186" ax="1" cpp="1" dn="1" events="1" outArgName="outStr">
            <gType>string</gType>
            <descrip>Continues keyboard-interactive authentication with the SSH server.   The ARG1 is typically the password.  If multiple responses are required (because there were multiple prompts in the infoRequest XML returned by StartKeyboardAuth), then the ARG1 should be formatted as XML (as shown below) otherwise the ARG1 simply contains the single response string.
&lt;pre&gt;
_LT_response_GT_
    _LT_response1_GT_response to first prompt_LT_/response1_GT_
    _LT_response2_GT_response to second prompt_LT_/response2_GT_
    ...
    _LT_responseN_GT_response to Nth prompt_LT_/responseN_GT_
_LT_/response_GT_
&lt;/pre&gt;

&lt;p&gt;If the interactive authentication completed with success or failure, the XML response will be:
&lt;pre&gt;
_LT_success_GT_success_message_LT_/success_GT_

or

_LT_error_GT_error_message_LT_/error_GT_
&lt;/pre&gt;
If additional steps are required to complete the interactive authentication, then an XML string that provides the name, instruction, and prompts is returned.   The XML has the following format:
&lt;pre&gt;
 	_LT_infoRequest numPrompts="N"_GT_
	    _LT_name_GT_name_string_LT_/name_GT_
	    _LT_instruction_GT_instruction_string_LT_/instruction_GT_
	    _LT_prompt1 echo="1_or_0"_GT_prompt_string_LT_/prompt1_GT_
	    ...
	    _LT_promptN echo="1_or_0"_GT_prompt_string_LT_/promptN_GT_
	_LT_/infoRequest_GT_
&lt;/pre&gt;</descrip>
            <iversion>9.5.0.46</iversion>
            <args>
                <arg>
                    <argName>response</argName>
                    <cppType>const char *</cppType>
                    <dnType>string</dnType>
                    <axType>string</axType>
                    <objcName>response</objcName>
                </arg>
                <arg>
                    <argName>outStr</argName>
                    <cppType>CkString &amp;</cppType>
                    <objcName>outStr</objcName>
                </arg>
            </args>
            <links2>
                <link linkType="example">
                    <url>ssh_keyboardAuthentication.asp</url>
                    <text>SSH Keyboard Authentication</text>
                </link>
            </links2>
            <args2>
                <arg name="response" type="string" objcName="response" />
            </args2>
        </method>
        <method cpp="1" dn="1" ax="1" name="Disconnect" axId="154">
            <gType>void</gType>
            <args />
            <descrip>Disconnects from the SSH server.</descrip>
            <args2 />
            <links2 />
        </method>
        <method cpp="1" dn="1" ax="1" name="GetChannelExitStatus" axId="155">
            <gType>int</gType>
            <args>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>channelNum</argName>
                    <objcName>channelNum</objcName>
                </arg>
            </args>
            <descrip>Returns the exit status code for a channel.  This method should only be called if an exit status has been received.  You may check to see if the exit status was received by calling ChannelReceivedExitStatus.</descrip>
            <args2>
                <arg name="channelNum" type="int" objcName="channelNum" />
            </args2>
            <links2 />
        </method>
        <method cpp="1" dn="1" ax="1" name="GetChannelNumber" axId="156">
            <gType>int</gType>
            <args>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>index</argName>
                    <objcName>index</objcName>
                </arg>
            </args>
            <descrip>Returns the channel number for the Nth open channel.  Indexing begins at 0, and the number of currently open channels is indicated by the NumOpenChannels property.  Returns -1 if the index is out of range.</descrip>
            <args2>
                <arg name="index" type="int" objcName="index" />
            </args2>
            <links2 />
        </method>
        <method cpp="1" dn="1" ax="1" name="GetChannelType" axId="157" outArgName="outStr">
            <gType>string</gType>
            <args>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>index</argName>
                    <objcName>index</objcName>
                </arg>
                <arg>
                    <cppType>CkString &amp;</cppType>
                    <argName>outStr</argName>
                    <objcName>outStr</objcName>
                </arg>
            </args>
            <descrip>Returns a string describing the channel type for the Nth open channel.   Channel types are:  "session", "x11", "forwarded-tcpip", and "direct-tcpip".</descrip>
            <args2>
                <arg name="index" type="int" objcName="index" />
            </args2>
            <links2 />
        </method>
        <method cpp="1" dn="1" ax="1" name="GetReceivedData" axId="158" outArgName="outBytes">
            <gType>bytes</gType>
            <args>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>channelNum</argName>
                    <objcName>channelNum</objcName>
                </arg>
                <arg>
                    <cppType>CkByteData &amp;</cppType>
                    <argName>outBytes</argName>
                    <objcName>outBytes</objcName>
                </arg>
            </args>
            <descrip>Returns the accumulated data received on the channel indicated by ARG1 and clears the channel's internal receive buffer.</descrip>
            <args2>
                <arg name="channelNum" type="int" objcName="channelNum" />
            </args2>
            <links2 />
        </method>
        <method cpp="1" dn="1" ax="1" name="GetReceivedDataN" axId="159" outArgName="outBytes">
            <gType>bytes</gType>
            <args>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>channelNum</argName>
                    <objcName>channelNum</objcName>
                </arg>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>maxNumBytes</argName>
                    <objcName>numBytes</objcName>
                </arg>
                <arg>
                    <cppType>CkByteData &amp;</cppType>
                    <argName>outBytes</argName>
                    <objcName>outBytes</objcName>
                </arg>
            </args>
            <descrip>Same as GetReceivedData, but a maximum of ARG2 bytes is returned.</descrip>
            <args2>
                <arg name="channelNum" type="int" objcName="channelNum" />
                <arg name="maxNumBytes" type="int" objcName="numBytes" />
            </args2>
            <links2 />
        </method>
        <method cpp="1" dn="1" ax="1" name="GetReceivedNumBytes" axId="160">
            <gType>int</gType>
            <args>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>channelNum</argName>
                    <objcName>channelNum</objcName>
                </arg>
            </args>
            <descrip>Returns the number of bytes available in the internal receive buffer for the specified ARG1.  The received data may be retrieved by calling GetReceivedData or GetReceivedText.</descrip>
            <args2>
                <arg name="channelNum" type="int" objcName="channelNum" />
            </args2>
            <links2 />
        </method>
        <method name="GetReceivedStderr" axId="161" ax="1" cpp="1" dn="1" outArgName="outBytes">
            <gType>bytes</gType>
            <args>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>channelNum</argName>
                    <objcName>channelNum</objcName>
                </arg>
                <arg>
                    <cppType>CkByteData &amp;</cppType>
                    <argName>outBytes</argName>
                    <objcName>outBytes</objcName>
                </arg>
            </args>
            <descrip>Returns the accumulated stderr bytes received on the channel indicated by ARG1 and clears the channel's internal stderr receive buffer.   
&lt;p&gt;
Note: If the StderrToStdout property is set to _TRUE_, then stderr is automatically redirected to stdout.  This is the default behavior.  The following methods can be called to retrieve the channel's stdout:  GetReceivedData, GetReceivedDataN, GetReceivedText, and GetReceivedTextS.</descrip>
            <iversion>9.5.0.48</iversion>
            <args2>
                <arg name="channelNum" type="int" objcName="channelNum" />
            </args2>
            <links2 />
        </method>
        <method cpp="1" dn="1" ax="1" name="GetReceivedStderrText" axId="189" outArgName="outStr">
            <gType>string</gType>
            <args>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>channelNum</argName>
                    <objcName>channelNum</objcName>
                </arg>
                <arg>
                    <axType>string</axType>
                    <dnType>string</dnType>
                    <cppType>const char *</cppType>
                    <argName>charset</argName>
                    <objcName>charset</objcName>
                </arg>
                <arg>
                    <cppType>CkString &amp;</cppType>
                    <argName>outStr</argName>
                    <objcName>outStr</objcName>
                </arg>
            </args>
            <descrip>Returns the accumulated stderr text received on the channel indicated by ARG1 and clears the channel's internal receive buffer.   The ARG2 indicates the charset of the character data in the internal receive buffer.  A list of supported charset values may be found on this page: &lt;a href="http://www.chilkatsoft.com/p/p_463.asp"&gt;Supported Charsets&lt;/a&gt;.</descrip>
            <args2>
                <arg name="channelNum" type="int" objcName="channelNum" />
                <arg name="charset" type="string" objcName="charset" />
            </args2>
            <links2 />
        </method>
        <method name="GetReceivedText" axId="162" outArgName="outStr" ax="1" cpp="1" dn="1">
            <gType>string</gType>
            <args>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>channelNum</argName>
                    <objcName>channelNum</objcName>
                </arg>
                <arg>
                    <axType>string</axType>
                    <dnType>string</dnType>
                    <cppType>const char *</cppType>
                    <argName>charset</argName>
                    <objcName>charset</objcName>
                </arg>
                <arg>
                    <cppType>CkString &amp;</cppType>
                    <argName>outStr</argName>
                    <objcName>outStr</objcName>
                </arg>
            </args>
            <descrip>Returns the accumulated text received on the channel indicated by ARG1 and clears the channel's internal receive buffer.   The ARG2 indicates the charset of the character data in the internal receive buffer.  A list of supported charset values may be found on this page: &lt;a href="http://www.chilkatsoft.com/p/p_463.asp"&gt;Supported Charsets&lt;/a&gt;.</descrip>
            <args2>
                <arg name="channelNum" type="int" objcName="channelNum" />
                <arg name="charset" type="string" objcName="charset" />
            </args2>
            <links2 />
        </method>
        <method cpp="1" dn="1" ax="1" name="GetReceivedTextS" axId="163" outArgName="outStr">
            <gType>string</gType>
            <args>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>channelNum</argName>
                    <objcName>channelNum</objcName>
                </arg>
                <arg>
                    <axType>string</axType>
                    <dnType>string</dnType>
                    <cppType>const char *</cppType>
                    <argName>substr</argName>
                    <objcName>substr</objcName>
                </arg>
                <arg>
                    <axType>string</axType>
                    <dnType>string</dnType>
                    <cppType>const char *</cppType>
                    <argName>charset</argName>
                    <objcName>charset</objcName>
                </arg>
                <arg>
                    <cppType>CkString &amp;</cppType>
                    <argName>outStr</argName>
                    <objcName>outStr</objcName>
                </arg>
            </args>
            <descrip>The same as GetReceivedText, except only the text up to and including ARG2 is returned.  The text returned is removed from the internal receive buffer.  If the ARG2 was not found in the internal receive buffer, an empty string is returned and the internal receive buffer is not modified.</descrip>
            <args2>
                <arg name="channelNum" type="int" objcName="channelNum" />
                <arg name="substr" type="string" objcName="substr" />
                <arg name="charset" type="string" objcName="charset" />
            </args2>
            <links2 />
        </method>
        <method cpp="1" dn="1" ax="1" events="1" name="OpenCustomChannel" axId="164">
            <gType>int</gType>
            <args>
                <arg>
                    <axType>string</axType>
                    <dnType>string</dnType>
                    <cppType>const char *</cppType>
                    <argName>channelType</argName>
                    <objcName>channelType</objcName>
                </arg>
            </args>
            <descrip>Opens a custom channel with a custom server that uses the SSH protocol.  The ARG1 is application-defined.
&lt;p&gt;
If successful, the channel number is returned.  This is the number that should be passed to any method requiring a channel number.  A -1 is returned upon failure.</descrip>
            <args2>
                <arg name="channelType" type="string" objcName="channelType" />
            </args2>
            <links2 />
        </method>
        <method cpp="1" dn="1" ax="1" events="1" name="OpenDirectTcpIpChannel" axId="165">
            <gType>int</gType>
            <args>
                <arg>
                    <axType>string</axType>
                    <dnType>string</dnType>
                    <cppType>const char *</cppType>
                    <argName>targetHostname</argName>
                    <objcName>hostname</objcName>
                </arg>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>targetPort</argName>
                    <objcName>port</objcName>
                </arg>
            </args>
            <descrip>Open a direct-tcpip channel for port forwarding. Data sent on the channel via ChannelSend* methods is sent to the SSH server and then forwarded to ARG1:ARG2.  The SSH server automatically forwards data received from ARG1:ARG2 to the SSH client.  Therefore, calling ChannelRead* and ChannelReceive* methods is equivalent to reading directly from ARG1:ARG2.  
&lt;p&gt;
If successful, the channel number is returned.  This is the number that should be passed to any method requiring a channel number.  A -1 is returned upon failure.</descrip>
            <links2>
                <link linkType="example">
                    <text>SSH Tunnel (Port Forwarding via direct-tcpip channel)</text>
                    <url>ssh_tunnel.asp</url>
                </link>
            </links2>
            <args2>
                <arg name="targetHostname" type="string" objcName="hostname" />
                <arg name="targetPort" type="int" objcName="port" />
            </args2>
        </method>
        <method cpp="1" dn="1" ax="1" events="1" name="OpenSessionChannel" axId="166">
            <gType>int</gType>
            <args />
            <descrip>Opens a new session channel.  Almost everything you will do with the Chilkat SSH component will involve opening a session channel.  The normal sequence of operation is typically this:  1) Connect to the SSH server.  2) Authenticate.  3) Open a session channel.  4) do something on the channel such as opening a shell, execute a command, etc.
&lt;p&gt;
If successful, the channel number is returned.  This is the number that should be passed to any method requiring a channel number.  A -1 is returned upon failure.</descrip>
            <args2 />
            <links2 />
        </method>
        <method cpp="1" dn="1" ax="1" name="PeekReceivedText" axId="167" outArgName="outStr">
            <gType>string</gType>
            <args>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>channelNum</argName>
                    <objcName>channelNum</objcName>
                </arg>
                <arg>
                    <axType>string</axType>
                    <dnType>string</dnType>
                    <cppType>const char *</cppType>
                    <argName>charset</argName>
                    <objcName>charset</objcName>
                </arg>
                <arg>
                    <cppType>CkString &amp;</cppType>
                    <argName>outStr</argName>
                    <objcName>outStr</objcName>
                </arg>
            </args>
            <descrip>This is the same as GetReceivedText, except the internal receive buffer is not cleared.</descrip>
            <args2>
                <arg name="channelNum" type="int" objcName="channelNum" />
                <arg name="charset" type="string" objcName="charset" />
            </args2>
            <links2 />
        </method>
        <method cpp="1" dn="1" ax="1" events="1" status="1" name="ReKey" axId="168">
            <gType>bool</gType>
            <args />
            <descrip>Initiates a  re-key with the SSH server.  The ReKey method does not return until the key re-exchange is complete.  
&lt;p&gt;
RFC 4253 (the SSH Transport Layer Protocol) recommends that keys be changed after each gigabyte of transmitted data or after each hour of connection time, whichever comes sooner.  Key re-exchange is a public-key operation and requires a fair amount of processing power and should not be performed too often.  Either side (client or server) may initiate a key re-exchange at any time.
&lt;p&gt;
In most cases, a server will automatically initiate key re-exchange whenever it deems necessary, and the Chilkat SSH component handles these transparently.  For example, if the Chilkat SSH component receives a re-key message from the server while in the process of receiving data on a channel, it will automatically handle the key re-exchange and the application will not even realize that an underlying key re-exchange occurred.</descrip>
            <args2 />
            <links2 />
        </method>
        <method cpp="1" dn="1" ax="1" events="1" status="1" name="SendIgnore" axId="169">
            <gType>bool</gType>
            <args />
            <descrip>Sends an IGNORE message to the SSH server.  This is one way of verifying that the connection to the SSH server is open and valid.  The SSH server does not response it an IGNORE message, it simply ignores it.  IGNORE messages are not associated with a channel (in other words, you do not need to first open a channel prior to sending an IGNORE message).</descrip>
            <args2 />
            <links2 />
        </method>
        <method name="SendReqExec" axId="170" ax="1" cpp="1" dn="1" events="1" status="1">
            <gType>bool</gType>
            <args>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>channelNum</argName>
                    <objcName>channelNum</objcName>
                </arg>
                <arg>
                    <axType>string</axType>
                    <dnType>string</dnType>
                    <cppType>const char *</cppType>
                    <argName>commandLine</argName>
                    <objcName>command</objcName>
                </arg>
            </args>
            <descrip>Initiates execution of a command on the channel specified by ARG1.  The ARG2 contains the full command line including any command-line parameters (just as you would type the command at a shell prompt).  
&lt;p&gt;
The user's default shell (typically defined in /etc/password in UNIX systems) is started on the SSH server to execute the command.
&lt;p&gt;
&lt;b&gt;Important:&lt;/b&gt; A channel only exists for a single request.  You may not call SendReqExec multiple times on the same open channel.  The reason is that the SSH server automatically closes the channel at the end of the exec.  The solution is to call OpenSessionChannel to get a new channel, and then call SendReqExec using the new channel.  It is OK to have more than one channel open simultaneously.
&lt;p&gt;&lt;b&gt;Charset:&lt;/b&gt; The ReqExecCharset property has been added in version 9.5.0.47.  This can be set to control the character encoding of the command sent to the server.  The default is ANSI.  A likely alternative value is "utf-8".</descrip>
            <links2>
                <link linkType="external">
                    <text>Note about sending commands that produce no output.</text>
                    <url>http://www.cknotes.com/?p=322</url>
                </link>
                <link linkType="external">
                    <text>Note about sending interactive commands such as "more"</text>
                    <url>http://www.cknotes.com/?p=323</url>
                </link>
                <link linkType="example">
                    <text>SSH Exec (Execute Command Line)</text>
                    <url>ssh_exec.asp</url>
                </link>
                <link linkType="example">
                    <text>Multiple SendReqExec on Same Connection</text>
                    <url>ssh_exec_sequence.asp</url>
                </link>
                <link linkType="external">
                    <url>http://www.chilkatforum.com/questions/1272/understanding-ssh-automation</url>
                    <text>Understanding SSH Automation</text>
                </link>
            </links2>
            <args2>
                <arg name="channelNum" type="int" objcName="channelNum" />
                <arg name="commandLine" type="string" objcName="command" />
            </args2>
        </method>
        <method name="SendReqPty" axId="171" ax="1" cpp="1" dn="1" events="1" status="1">
            <gType>bool</gType>
            <args>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>channelNum</argName>
                    <objcName>channelNum</objcName>
                </arg>
                <arg>
                    <axType>string</axType>
                    <dnType>string</dnType>
                    <cppType>const char *</cppType>
                    <argName>termType</argName>
                    <objcName>xTermEnvVar</objcName>
                </arg>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>widthInChars</argName>
                    <objcName>widthInChars</objcName>
                </arg>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>heightInChars</argName>
                    <objcName>heightInRows</objcName>
                </arg>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>widthInPixels</argName>
                    <objcName>pixWidth</objcName>
                </arg>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>heightInPixels</argName>
                    <objcName>pixHeight</objcName>
                </arg>
            </args>
            <descrip>Requests a pseudo-terminal for a session channel.  If the ARG2 is a character oriented terminal ("vt100" for example), then ARG3 and ARG4 would be set to non-zero values, while ARG5 and ARG6 may be set to 0.  If ARG2 is pixel-oriented, such as "xterm", the reverse is true (i.e. set ARG5 and ARG6, but set ARG3 and ARG4 equal to 0).&lt;p&gt;
In most cases, you probably don't even want terminal emulation.  In that case, try setting ARG2 = "dumb".  Terminal emulation causes terminal escape sequences to be included with shell command output.  A "dumb" terminal should have no escape sequences.
&lt;p&gt;
Some SSH servers allow a shell to be started (via the SendReqShell method) without the need to first request a pseudo-terminal.  The normal sequence for starting a remote shell is as follows:
&lt;pre&gt;
1) Connect
2) Authenticate
3) OpenSessionChannel
4) Request a PTY via this method if necessary.
5) Start a shell by calling SendReqShell
&lt;/pre&gt;</descrip>
            <links2>
                <link linkType="external">
                    <url>http://www.chilkatforum.com/questions/1272/understanding-ssh-automation</url>
                    <text>Understanding SSH Automation</text>
                </link>
            </links2>
            <args2>
                <arg name="channelNum" type="int" objcName="channelNum" />
                <arg name="termType" type="string" objcName="xTermEnvVar" />
                <arg name="widthInChars" type="int" objcName="widthInChars" />
                <arg name="heightInChars" type="int" objcName="heightInRows" />
                <arg name="widthInPixels" type="int" objcName="pixWidth" />
                <arg name="heightInPixels" type="int" objcName="pixHeight" />
            </args2>
        </method>
        <method cpp="1" dn="1" ax="1" events="1" status="1" name="SendReqSetEnv" axId="172">
            <gType>bool</gType>
            <args>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>channelNum</argName>
                    <objcName>channelNum</objcName>
                </arg>
                <arg>
                    <axType>string</axType>
                    <dnType>string</dnType>
                    <cppType>const char *</cppType>
                    <argName>name</argName>
                    <objcName>name</objcName>
                </arg>
                <arg>
                    <axType>string</axType>
                    <dnType>string</dnType>
                    <cppType>const char *</cppType>
                    <argName>value</argName>
                    <objcName>value</objcName>
                </arg>
            </args>
            <descrip>Sets an environment variable in the remote shell.</descrip>
            <args2>
                <arg name="channelNum" type="int" objcName="channelNum" />
                <arg name="name" type="string" objcName="name" />
                <arg name="value" type="string" objcName="value" />
            </args2>
            <links2 />
        </method>
        <method name="SendReqShell" axId="173" ax="1" cpp="1" dn="1" events="1" status="1">
            <gType>bool</gType>
            <args>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>channelNum</argName>
                    <objcName>channelNum</objcName>
                </arg>
            </args>
            <descrip>Starts a shell on an open session channel.  Some SSH servers require that a PTY (pseudo-terminal) first be requested prior to starting a shell.  In that case, call SendReqPty prior to calling this method.  Once a shell is started, commands may be sent by calling ChannelSendString.  (Don't forget to terminate commands with a CRLF).</descrip>
            <links2>
                <link linkType="example">
                    <text>SSH Remote Shell</text>
                    <url>ssh_remote_command.asp</url>
                </link>
                <link linkType="example" lang="perl">
                    <text>SSH -- Running Commands that Prompt for Additional Input, such as "su"</text>
                    <url>ssh_su.asp</url>
                </link>
                <link linkType="example" lang="csharp">
                    <text>SSH -- Running Commands that Prompt for Additional Input, such as "su"</text>
                    <url>ssh_su.asp</url>
                </link>
                <link linkType="external">
                    <url>http://www.chilkatforum.com/questions/1272/understanding-ssh-automation</url>
                    <text>Understanding SSH Automation</text>
                </link>
            </links2>
            <args2>
                <arg name="channelNum" type="int" objcName="channelNum" />
            </args2>
        </method>
        <method cpp="1" dn="1" ax="1" events="1" status="1" name="SendReqSignal" axId="174">
            <gType>bool</gType>
            <args>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>channelNum</argName>
                    <objcName>channelNum</objcName>
                </arg>
                <arg>
                    <axType>string</axType>
                    <dnType>string</dnType>
                    <cppType>const char *</cppType>
                    <argName>signalName</argName>
                    <objcName>signalName</objcName>
                </arg>
            </args>
            <descrip>Delivers a signal to the remote process/service.   ARG2 is one of the following:  ABRT, ALRM, FPE, HUP, ILL, INT, KILL, PIPE, QUIT, SEGV, TERM, USR1, USR2.  (Obviously, these are UNIX signals, so the remote SSH server would need to be a Unix/Linux system.)</descrip>
            <args2>
                <arg name="channelNum" type="int" objcName="channelNum" />
                <arg name="signalName" type="string" objcName="signalName" />
            </args2>
            <links2 />
        </method>
        <method cpp="1" dn="1" ax="1" events="1" status="1" name="SendReqSubsystem" axId="175">
            <gType>bool</gType>
            <args>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>channelNum</argName>
                    <objcName>channelNum</objcName>
                </arg>
                <arg>
                    <axType>string</axType>
                    <dnType>string</dnType>
                    <cppType>const char *</cppType>
                    <argName>subsystemName</argName>
                    <objcName>subsystemName</objcName>
                </arg>
            </args>
            <descrip>Executes a pre-defined subsystem.  The SFTP protocol (Secure File Transfer Protocol) is started by the Chilkat SFTP component by starting the "sftp" subsystem.</descrip>
            <args2>
                <arg name="channelNum" type="int" objcName="channelNum" />
                <arg name="subsystemName" type="string" objcName="subsystemName" />
            </args2>
            <links2 />
        </method>
        <method cpp="1" dn="1" ax="1" events="1" name="SendReqWindowChange" axId="176">
            <gType>bool</gType>
            <args>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>channelNum</argName>
                    <objcName>channelNum</objcName>
                </arg>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>widthInChars</argName>
                    <objcName>widthInChars</objcName>
                </arg>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>heightInRows</argName>
                    <objcName>heightInRows</objcName>
                </arg>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>pixWidth</argName>
                    <objcName>pixWidth</objcName>
                </arg>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>pixHeight</argName>
                    <objcName>pixHeight</objcName>
                </arg>
            </args>
            <descrip>When the client-side window (terminal) size changes, this message may be sent to the server to inform it of the new size.</descrip>
            <args2>
                <arg name="channelNum" type="int" objcName="channelNum" />
                <arg name="widthInChars" type="int" objcName="widthInChars" />
                <arg name="heightInRows" type="int" objcName="heightInRows" />
                <arg name="pixWidth" type="int" objcName="pixWidth" />
                <arg name="pixHeight" type="int" objcName="pixHeight" />
            </args2>
            <links2 />
        </method>
        <method cpp="1" dn="1" ax="1" events="1" name="SendReqX11Forwarding" axId="177">
            <gType>bool</gType>
            <args>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>channelNum</argName>
                    <objcName>channelNum</objcName>
                </arg>
                <arg>
                    <axType>bool</axType>
                    <dnType>bool</dnType>
                    <cppType>bool</cppType>
                    <argName>singleConnection</argName>
                    <objcName>singleConnection</objcName>
                </arg>
                <arg>
                    <axType>string</axType>
                    <dnType>string</dnType>
                    <cppType>const char *</cppType>
                    <argName>authProt</argName>
                    <objcName>authProt</objcName>
                </arg>
                <arg>
                    <axType>string</axType>
                    <dnType>string</dnType>
                    <cppType>const char *</cppType>
                    <argName>authCookie</argName>
                    <objcName>authCookie</objcName>
                </arg>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>screenNum</argName>
                    <objcName>screenNum</objcName>
                </arg>
            </args>
            <descrip>Allows the client to send an X11 forwarding request to the server.  Chilkat only provides this functionality because it is a message defined in the SSH connection protocol. Chilkat has no advice for when or why it would be needed.</descrip>
            <args2>
                <arg name="channelNum" type="int" objcName="channelNum" />
                <arg name="singleConnection" type="bool" objcName="singleConnection" />
                <arg name="authProt" type="string" objcName="authProt" />
                <arg name="authCookie" type="string" objcName="authCookie" />
                <arg name="screenNum" type="int" objcName="screenNum" />
            </args2>
            <links2 />
        </method>
        <method cpp="1" dn="1" ax="1" events="1" name="SendReqXonXoff" axId="178">
            <gType>bool</gType>
            <args>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>channelNum</argName>
                    <objcName>channelNum</objcName>
                </arg>
                <arg>
                    <axType>bool</axType>
                    <dnType>bool</dnType>
                    <cppType>bool</cppType>
                    <argName>clientCanDo</argName>
                    <objcName>clientCanDo</objcName>
                </arg>
            </args>
            <descrip>This method should be ignored and not used.</descrip>
            <args2>
                <arg name="channelNum" type="int" objcName="channelNum" />
                <arg name="clientCanDo" type="bool" objcName="clientCanDo" />
            </args2>
            <links2 />
        </method>
        <method cpp="1" dn="1" ax="1" name="SetTtyMode" axId="179">
            <gType>bool</gType>
            <args>
                <arg>
                    <axType>string</axType>
                    <dnType>string</dnType>
                    <cppType>const char *</cppType>
                    <argName>ttyName</argName>
                    <objcName>name</objcName>
                </arg>
                <arg>
                    <axType>int</axType>
                    <dnType>int</dnType>
                    <cppType>int</cppType>
                    <argName>ttyValue</argName>
                    <objcName>value</objcName>
                </arg>
            </args>
            <descrip>Sets a TTY mode that is included in the SendReqPty method call.  Most commonly, it is not necessary to call this method at all. Chilkat has no recommendations or expertise as to why or when a particular mode might be useful.  This capability is provided because it is defined in the SSH connection protocol specification. 
&lt;p&gt;This method can be called multiple times to set many terminal mode flags (one per call).   
&lt;p&gt;
The ARG2 is an integer, typically 0 or 1.  Valid ARG1 flag names include: VINTR,
VQUIT,
VERASE,
VKILL,
VEOF,
VEOL,
VEOL2,
VSTART,
VSTOP,
VSUSP,
VDSUSP,
VREPRINT,
VWERASE,
VLNEXT,
VFLUSH,
VSWTCH,
VSTATUS,
VDISCARD,
IGNPAR,
PARMRK,
INPCK,
ISTRIP,
INLCR,
IGNCR,
ICRNL,
IUCLC,
IXON,
IXANY,
IXOFF,
IMAXBEL,
ISIG,
ICANON,
XCASE,
ECHO,
ECHOE,
ECHOK,
ECHONL,
NOFLSH,
TOSTOP,
IEXTEN,
ECHOCTL,
ECHOKE,
PENDIN,
OPOST,
OLCUC,
ONLCR,
OCRNL,
ONOCR,
ONLRET,
CS7,
CS8,
PARENB,
PARODD,
TTY_OP_ISPEED,
TTY_OP_OSPEED</descrip>
            <args2>
                <arg name="ttyName" type="string" objcName="name" />
                <arg name="ttyValue" type="int" objcName="value" />
            </args2>
            <links2 />
        </method>
        <method name="StartKeyboardAuth" axId="184" ax="1" cpp="1" dn="1" events="1" outArgName="outStr">
            <gType>string</gType>
            <descrip>Begins keyboard-interactive authentication with the SSH server.   Returns an XML string providing the name, instruction, and prompts.   The XML has the following format:
&lt;pre&gt;
 	_LT_infoRequest numPrompts="N"_GT_
	    _LT_name_GT_name_string_LT_/name_GT_
	    _LT_instruction_GT_instruction_string_LT_/instruction_GT_
	    _LT_prompt1 echo="1_or_0"_GT_prompt_string_LT_/prompt1_GT_
	    ...
	    _LT_promptN echo="1_or_0"_GT_prompt_string_LT_/promptN_GT_
	_LT_/infoRequest_GT_
&lt;/pre&gt;
&lt;p&gt;If the authentication immediately succeeds because no password is required, or immediately fails, the XML response can be:
&lt;pre&gt;
_LT_success_GT_success_message_LT_/success_GT_

or

_LT_error_GT_error_message_LT_/error_GT_
&lt;/pre&gt;</descrip>
            <iversion>9.5.0.46</iversion>
            <args>
                <arg>
                    <argName>login</argName>
                    <cppType>const char *</cppType>
                    <dnType>string</dnType>
                    <axType>string</axType>
                    <objcName>login</objcName>
                </arg>
                <arg>
                    <argName>outStr</argName>
                    <cppType>CkString &amp;</cppType>
                    <objcName>outStr</objcName>
                </arg>
            </args>
            <links2>
                <link linkType="example">
                    <url>ssh_keyboardAuthentication.asp</url>
                    <text>SSH Keyboard Authentication</text>
                </link>
            </links2>
            <args2>
                <arg name="login" type="string" objcName="login" />
            </args2>
        </method>
        <method cpp="1" dn="1" ax="1" status="1" name="UnlockComponent" axId="180">
            <gType>bool</gType>
            <args>
                <arg>
                    <axType>string</axType>
                    <dnType>string</dnType>
                    <cppType>const char *</cppType>
                    <argName>unlockCode</argName>
                    <objcName>unlockCode</objcName>
                </arg>
            </args>
            <descrip>Unlocks the component. This must be called once prior to calling any other method.  A fully-functional 30-day trial is automatically started when an arbitrary string is passed to this method.  For example, passing "Hello", or "abc123" will unlock the component for the 1st thirty days after the initial install.</descrip>
            <args2>
                <arg name="unlockCode" type="string" objcName="unlockCode" />
            </args2>
            <links2>
                <link linkType="external">
                    <text>Diagnosing UnlockComponent Problems</text>
                    <url>http://www.cknotes.com/?p=168</url>
                </link>
                <link linkType="external">
                    <text>UnlockComponent LastErrorText shows exact string passed to it.</text>
                    <url>http://www.cknotes.com/?p=315</url>
                </link>
                <link linkType="external">
                    <text>Verify UnlockComponent Success w/ Permanent Unlock Code</text>
                    <url>http://www.cknotes.com/?p=317</url>
                </link>
                <link linkType="external">
                    <text>LastErrorText Standard Information</text>
                    <url>http://www.cknotes.com/?p=316</url>
                </link>
            </links2>
        </method>
        <method name="WaitForChannelMessage" axId="190" ax="1" cpp="1" dn="1" events="1">
            <gType>int</gType>
            <descrip>The ARG1 is the number of milliseconds to wait.  To poll, pass a value of 0 in ARG1.  Waits for an incoming message on any channel.  This includes data, EOF, CLOSE, etc.   If a message arrives in the alotted time, the channel number is returned.  A value of -1 is returned for a timeout, and -2 for any other errors such as if the connection is lost.
&lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; If a channel number is returned, the message must still be read by calling a method such as ChannelRead, ChannelReceiveUntilMatch, etc.  Once the message is actually received, it may be collected by calling GetReceivedText, GetReceivedData, etc.</descrip>
            <iversion>9.5.0.48</iversion>
            <args>
                <arg>
                    <argName>pollTimeoutMs</argName>
                    <cppType>int</cppType>
                    <dnType>int</dnType>
                    <axType>int</axType>
                    <objcName>pollTimeoutMs</objcName>
                </arg>
            </args>
            <args2>
                <arg name="pollTimeoutMs" type="int" objcName="pollTimeoutMs" />
            </args2>
            <links2 />
        </method>
        <method name="QuickCommand" axId="196" ax="1" cpp="1" dn="1" events="1">
            <gType>string</gType>
            <descrip>Simplified method for executing a remote command and getting the complete output.  This is the equivalent of calling OpenSessionChannel, followed by SendReqExec, then ChannelReceiveToClose, and finally GetReceivedText.
&lt;p&gt;
 The ARG2 indicates the charset of the command's output (such as "utf-8" or "ansi").  A list of supported charset values may be found on this page: &lt;a href="http://www.chilkatsoft.com/p/p_463.asp"&gt;Supported Charsets&lt;/a&gt;.
&lt;p&gt;
The ReqExecCharset property controls the charset used for the command that is sent.
&lt;p&gt;
Important: When reporting problems, please send the full contents of the LastErrorText property to support@chilkatsoft.com.</descrip>
            <args2>
                <arg name="command" type="string" objcName="command" />
                <arg name="charset" type="string" objcName="charset" />
            </args2>
            <links2>
                <link linkType="example">
                    <url>ssh_execute_remote_commands.asp</url>
                    <text>SSH Execute Remote Commands</text>
                </link>
            </links2>
            <iversion>9.5.0.65</iversion>
        </method>
        <method name="QuickShell" axId="197" ax="1" cpp="1" dn="1" events="1">
            <gType>int</gType>
            <descrip>Simplified method for starting a remote shell session.  It is the equivalent of calling OpenSessionChannel, followed by SendReqPty, and finally SendReqShell. 
&lt;p&gt;
Returns the SSH channel number for the session, or -1 if not successful.
&lt;p&gt;
Important: When reporting problems, please send the full contents of the LastErrorText property to support@chilkatsoft.com.</descrip>
            <args2 />
            <iversion>9.5.0.65</iversion>
            <links2>
                <link linkType="example">
                    <url>ssh_quick_shell_session.asp</url>
                    <text>SSH Quick/Simple Shell Session</text>
                </link>
            </links2>
        </method>
        <method name="QuickCmdSend" axId="198" ax="1" cpp="1" dn="1" events="1">
            <gType>int</gType>
            <descrip>Sends a command and returns the channel number for the command that has started.  This is the equivalent of calling OpenSessionChannel, followed by SendReqExec.   A value of -1 is returned on failure.
&lt;p&gt;
The ReqExecCharset property controls the charset used for the command that is sent.
&lt;p&gt;
Important: When reporting problems, please send the full contents of the LastErrorText property to support@chilkatsoft.com.</descrip>
            <args2>
                <arg name="command" type="string" objcName="command" />
            </args2>
            <iversion>9.5.0.65</iversion>
            <links2>
                <link linkType="example">
                    <url>ssh_parallel_remote_commands.asp</url>
                    <text>SSH Parallel Remote Commands on Single Server</text>
                </link>
                <link linkType="example">
                    <url>ssh_parallel_multiple_servers.asp</url>
                    <text>SSH Parallel Remote Commands on Multiple Servers</text>
                </link>
            </links2>
        </method>
        <method name="QuickCmdCheck" axId="199" ax="1" cpp="1" dn="1" events="1">
            <gType>int</gType>
            <descrip>Returns a channel number for a completed command that was previously sent via QuickCmdSend.  Returns -1 if no commands have yet completed.  The ARG1 indicates how long to wait (in milliseconds) for any command in progress (on any channel) to complete before returning -1.   
&lt;p&gt;
Returns -2 if an error occurred (for example, if the connection to the SSH server was lost while checking for responses).</descrip>
            <args2>
                <arg name="pollTimeoutMs" type="int" objcName="pollTimeoutMs" />
            </args2>
            <iversion>9.5.0.65</iversion>
            <links2>
                <link linkType="example">
                    <url>ssh_parallel_remote_commands.asp</url>
                    <text>SSH Parallel Remote Commands on Single Server</text>
                </link>
                <link linkType="example">
                    <url>ssh_parallel_multiple_servers.asp</url>
                    <text>SSH Parallel Remote Commands on Multiple Servers</text>
                </link>
            </links2>
        </method>
    </methods>
    <genericName>Ssh</genericName>
    <events>
        <standard name="AbortCheck" />
        <standard name="PercentDone" />
        <standard name="ProgressInfo" />
        <standard name="TaskCompleted" />
    </events>
    <description>A client-side SSH2 implementation for executing commands and shell sessions on Unix/Windows SSH servers.</description>
    <clsid>D67AF44C-0AA8-424A-AF73-2070B4C11781</clsid>
    <typeid>004CB902-F437-4D01-BD85-9E18836DA5C2</typeid>
    <uuidEvents>24FFBB84-D4B7-4DBD-897D-B625ACF61F91</uuidEvents>
    <uuidMidl>792D2027-B40F-4894-9248-5E9A3FA09F36</uuidMidl>
    <nextAxId>200</nextAxId>
</class>
