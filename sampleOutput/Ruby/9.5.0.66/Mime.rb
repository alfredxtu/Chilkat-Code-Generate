module Chilkat
	class CkMime 
		# The boundary string for a multipart MIME message. 
		# It is the value of the boundary attribute
		# of the Content-Type header field. For example, if the Content-Type header is
		# this:
		# 
		# Content-Type: multipart/mixed;
		# boundary="------------080707010302060306060800"
		# 
		# then the value of the Boundary property
		# is "------------080707010302060306060800".
		# 
		# When building multipart MIME messages, the
		# boundary is automatically generated by methods such as NewMultipartMixed, to be a unique and random
		# string, so explicitly setting the boundary is usually not necessary.
		#
		# @param ckStr [CkString]
		#
		# @return [String]
		def get_Boundary(ckStr) end

		# The boundary string for a multipart MIME message. 
		# It is the value of the boundary attribute
		# of the Content-Type header field. For example, if the Content-Type header is
		# this:
		# 
		# Content-Type: multipart/mixed;
		# boundary="------------080707010302060306060800"
		# 
		# then the value of the Boundary property
		# is "------------080707010302060306060800".
		# 
		# When building multipart MIME messages, the
		# boundary is automatically generated by methods such as NewMultipartMixed, to be a unique and random
		# string, so explicitly setting the boundary is usually not necessary.
		#
		# @param newval [String]
		def put_Boundary(newval) end

		# The boundary string for a multipart MIME message. 
		# It is the value of the boundary attribute
		# of the Content-Type header field. For example, if the Content-Type header is
		# this:
		# 
		# Content-Type: multipart/mixed;
		# boundary="------------080707010302060306060800"
		# 
		# then the value of the Boundary property
		# is "------------080707010302060306060800".
		# 
		# When building multipart MIME messages, the
		# boundary is automatically generated by methods such as NewMultipartMixed, to be a unique and random
		# string, so explicitly setting the boundary is usually not necessary.
		#
		# @return [String]
		def boundary() end

		# The boundary string for a multipart MIME message. 
		# It is the value of the boundary attribute
		# of the Content-Type header field. For example, if the Content-Type header is
		# this:
		# 
		# Content-Type: multipart/mixed;
		# boundary="------------080707010302060306060800"
		# 
		# then the value of the Boundary property
		# is "------------080707010302060306060800".
		# 
		# When building multipart MIME messages, the
		# boundary is automatically generated by methods such as NewMultipartMixed, to be a unique and random
		# string, so explicitly setting the boundary is usually not necessary.
		#
		# @param newval [String]
		def put_Boundary(newval) end

		# The value of the "charset" attribute of the Content-Type header field. For example, if the
		# Content-Type header is this:
		# 
		# Content-Type: text/plain;
		# charset="iso-8859-1"
		# 
		# then the value of the Charset property is "iso-8859-1".
		#
		# @param ckStr [CkString]
		#
		# @return [String]
		def get_Charset(ckStr) end

		# The value of the "charset" attribute of the Content-Type header field. For example, if the
		# Content-Type header is this:
		# 
		# Content-Type: text/plain;
		# charset="iso-8859-1"
		# 
		# then the value of the Charset property is "iso-8859-1".
		#
		# @param newval [String]
		def put_Charset(newval) end

		# The value of the "charset" attribute of the Content-Type header field. For example, if the
		# Content-Type header is this:
		# 
		# Content-Type: text/plain;
		# charset="iso-8859-1"
		# 
		# then the value of the Charset property is "iso-8859-1".
		#
		# @return [String]
		def charset() end

		# The value of the "charset" attribute of the Content-Type header field. For example, if the
		# Content-Type header is this:
		# 
		# Content-Type: text/plain;
		# charset="iso-8859-1"
		# 
		# then the value of the Charset property is "iso-8859-1".
		#
		# @param newval [String]
		def put_Charset(newval) end

		# The MIME content type, such as "text/plain", "text/html", "image/gif", "multipart/alternative",
		# "multipart/mixed", etc.
		# It is the value of the Content-Type header field, excluding any
		# attributes. For example, if the Content-Type header is this:
		# 
		# Content-Type:
		# multipart/mixed; boundary="------------080707010302060306060800"
		# 
		# then the value of the
		# ContentType property is "multipart/mixed".
		#
		# @param ckStr [CkString]
		#
		# @return [String]
		def get_ContentType(ckStr) end

		# The MIME content type, such as "text/plain", "text/html", "image/gif", "multipart/alternative",
		# "multipart/mixed", etc.
		# It is the value of the Content-Type header field, excluding any
		# attributes. For example, if the Content-Type header is this:
		# 
		# Content-Type:
		# multipart/mixed; boundary="------------080707010302060306060800"
		# 
		# then the value of the
		# ContentType property is "multipart/mixed".
		#
		# @param newval [String]
		def put_ContentType(newval) end

		# The MIME content type, such as "text/plain", "text/html", "image/gif", "multipart/alternative",
		# "multipart/mixed", etc.
		# It is the value of the Content-Type header field, excluding any
		# attributes. For example, if the Content-Type header is this:
		# 
		# Content-Type:
		# multipart/mixed; boundary="------------080707010302060306060800"
		# 
		# then the value of the
		# ContentType property is "multipart/mixed".
		#
		# @return [String]
		def contentType() end

		# The MIME content type, such as "text/plain", "text/html", "image/gif", "multipart/alternative",
		# "multipart/mixed", etc.
		# It is the value of the Content-Type header field, excluding any
		# attributes. For example, if the Content-Type header is this:
		# 
		# Content-Type:
		# multipart/mixed; boundary="------------080707010302060306060800"
		# 
		# then the value of the
		# ContentType property is "multipart/mixed".
		#
		# @param newval [String]
		def put_ContentType(newval) end

		# Returns the current date/time in RFC 822 format.
		#
		# @return [String]
		def get_CurrentDateTime() end

		# Returns the current date/time in RFC 822 format.
		#
		# @return [String]
		def currentDateTime() end

		# If set to a file path, causes each Chilkat method or property call to automatically append it's
		# LastErrorText to the specified log file. The information is appended such that if a hang or crash
		# occurs, it is possible to see the context in which the problem occurred, as well as a history of all
		# Chilkat calls up to the point of the problem. The VerboseLogging property can be set to provide more
		# detailed information.
		# 
		# This property is typically used for debugging the rare cases
		# where a Chilkat method call hangs or generates an exception that halts program execution (i.e.
		# crashes). 
		# A hang or crash should generally never happen. The typical causes of a hang
		# are:
		# 
		# a timeout related property was set to 0 to explicitly indicate that an infinite
		# timeout is desired, 
		# the hang is actually a hang within an event callback (i.e. it is a hang
		# within the application code), or 
		# there is an internal problem (bug) in the Chilkat code that
		# causes the hang.
		#
		#
		# @param ckStr [CkString]
		#
		# @return [String]
		def get_DebugLogFilePath(ckStr) end

		# If set to a file path, causes each Chilkat method or property call to automatically append it's
		# LastErrorText to the specified log file. The information is appended such that if a hang or crash
		# occurs, it is possible to see the context in which the problem occurred, as well as a history of all
		# Chilkat calls up to the point of the problem. The VerboseLogging property can be set to provide more
		# detailed information.
		# 
		# This property is typically used for debugging the rare cases
		# where a Chilkat method call hangs or generates an exception that halts program execution (i.e.
		# crashes). 
		# A hang or crash should generally never happen. The typical causes of a hang
		# are:
		# 
		# a timeout related property was set to 0 to explicitly indicate that an infinite
		# timeout is desired, 
		# the hang is actually a hang within an event callback (i.e. it is a hang
		# within the application code), or 
		# there is an internal problem (bug) in the Chilkat code that
		# causes the hang.
		#
		#
		# @param newval [String]
		def put_DebugLogFilePath(newval) end

		# If set to a file path, causes each Chilkat method or property call to automatically append it's
		# LastErrorText to the specified log file. The information is appended such that if a hang or crash
		# occurs, it is possible to see the context in which the problem occurred, as well as a history of all
		# Chilkat calls up to the point of the problem. The VerboseLogging property can be set to provide more
		# detailed information.
		# 
		# This property is typically used for debugging the rare cases
		# where a Chilkat method call hangs or generates an exception that halts program execution (i.e.
		# crashes). 
		# A hang or crash should generally never happen. The typical causes of a hang
		# are:
		# 
		# a timeout related property was set to 0 to explicitly indicate that an infinite
		# timeout is desired, 
		# the hang is actually a hang within an event callback (i.e. it is a hang
		# within the application code), or 
		# there is an internal problem (bug) in the Chilkat code that
		# causes the hang.
		#
		#
		# @return [String]
		def debugLogFilePath() end

		# If set to a file path, causes each Chilkat method or property call to automatically append it's
		# LastErrorText to the specified log file. The information is appended such that if a hang or crash
		# occurs, it is possible to see the context in which the problem occurred, as well as a history of all
		# Chilkat calls up to the point of the problem. The VerboseLogging property can be set to provide more
		# detailed information.
		# 
		# This property is typically used for debugging the rare cases
		# where a Chilkat method call hangs or generates an exception that halts program execution (i.e.
		# crashes). 
		# A hang or crash should generally never happen. The typical causes of a hang
		# are:
		# 
		# a timeout related property was set to 0 to explicitly indicate that an infinite
		# timeout is desired, 
		# the hang is actually a hang within an event callback (i.e. it is a hang
		# within the application code), or 
		# there is an internal problem (bug) in the Chilkat code that
		# causes the hang.
		#
		#
		# @param newval [String]
		def put_DebugLogFilePath(newval) end

		# The value of the Content-Disposition header field, excluding any attributes. For example, if the
		# Content-Disposition header is this:
		# 
		# Content-Disposition: attachment;
		# filename="starfish.gif"
		# 
		# then the value of the Disposition property is "attachment".
		#
		# @param ckStr [CkString]
		#
		# @return [String]
		def get_Disposition(ckStr) end

		# The value of the Content-Disposition header field, excluding any attributes. For example, if the
		# Content-Disposition header is this:
		# 
		# Content-Disposition: attachment;
		# filename="starfish.gif"
		# 
		# then the value of the Disposition property is "attachment".
		#
		# @param newval [String]
		def put_Disposition(newval) end

		# The value of the Content-Disposition header field, excluding any attributes. For example, if the
		# Content-Disposition header is this:
		# 
		# Content-Disposition: attachment;
		# filename="starfish.gif"
		# 
		# then the value of the Disposition property is "attachment".
		#
		# @return [String]
		def disposition() end

		# The value of the Content-Disposition header field, excluding any attributes. For example, if the
		# Content-Disposition header is this:
		# 
		# Content-Disposition: attachment;
		# filename="starfish.gif"
		# 
		# then the value of the Disposition property is "attachment".
		#
		# @param newval [String]
		def put_Disposition(newval) end

		# The value of the Content-Transfer-Encoding header field. Typical values are "base64",
		# "quoted-printable", "7bit", "8bit", "binary", etc. For example, if the Content-Transfer-Encoding
		# header is this:
		# 
		# Content-Transfer-Encoding: base64
		# 
		# then the value of the
		# Encoding property is "base64".
		#
		# @param ckStr [CkString]
		#
		# @return [String]
		def get_Encoding(ckStr) end

		# The value of the Content-Transfer-Encoding header field. Typical values are "base64",
		# "quoted-printable", "7bit", "8bit", "binary", etc. For example, if the Content-Transfer-Encoding
		# header is this:
		# 
		# Content-Transfer-Encoding: base64
		# 
		# then the value of the
		# Encoding property is "base64".
		#
		# @param newval [String]
		def put_Encoding(newval) end

		# The value of the Content-Transfer-Encoding header field. Typical values are "base64",
		# "quoted-printable", "7bit", "8bit", "binary", etc. For example, if the Content-Transfer-Encoding
		# header is this:
		# 
		# Content-Transfer-Encoding: base64
		# 
		# then the value of the
		# Encoding property is "base64".
		#
		# @return [String]
		def encoding() end

		# The value of the Content-Transfer-Encoding header field. Typical values are "base64",
		# "quoted-printable", "7bit", "8bit", "binary", etc. For example, if the Content-Transfer-Encoding
		# header is this:
		# 
		# Content-Transfer-Encoding: base64
		# 
		# then the value of the
		# Encoding property is "base64".
		#
		# @param newval [String]
		def put_Encoding(newval) end

		# The value of the "filename" attribute of the Content-Disposition header field. For example, if the
		# Content-Disposition header is this:
		# 
		# Content-Disposition: attachment;
		# filename="starfish.gif"
		# 
		# then the value of the Filename property is "starfish.gif".
		#
		# @param ckStr [CkString]
		#
		# @return [String]
		def get_Filename(ckStr) end

		# The value of the "filename" attribute of the Content-Disposition header field. For example, if the
		# Content-Disposition header is this:
		# 
		# Content-Disposition: attachment;
		# filename="starfish.gif"
		# 
		# then the value of the Filename property is "starfish.gif".
		#
		# @param newval [String]
		def put_Filename(newval) end

		# The value of the "filename" attribute of the Content-Disposition header field. For example, if the
		# Content-Disposition header is this:
		# 
		# Content-Disposition: attachment;
		# filename="starfish.gif"
		# 
		# then the value of the Filename property is "starfish.gif".
		#
		# @return [String]
		def filename() end

		# The value of the "filename" attribute of the Content-Disposition header field. For example, if the
		# Content-Disposition header is this:
		# 
		# Content-Disposition: attachment;
		# filename="starfish.gif"
		# 
		# then the value of the Filename property is "starfish.gif".
		#
		# @param newval [String]
		def put_Filename(newval) end

		# The binary data returned by the last (binary data returning) method called. Only available if
		# Chilkat.Global.KeepBinaryResult is set to _TRUE_. This provides a means for obtaining large
		# varbinary results in the SQL Server environment (where limitations exist in getting large amounts of
		# data returned by method calls, but where temp tables can be used for binary properties).
		#
		# @param ckByteData [CkByteData]
		#
		# @return [Fixnum]
		def get_LastBinaryResult(ckByteData) end

		# Provides information in HTML format about the last method/property called. If a method call returns
		# a value indicating failure, or behaves unexpectedly, examine this property to get more information.
		#
		# @param ckStr [CkString]
		#
		# @return [String]
		def get_LastErrorHtml(ckStr) end

		# Provides information in HTML format about the last method/property called. If a method call returns
		# a value indicating failure, or behaves unexpectedly, examine this property to get more information.
		#
		# @return [String]
		def lastErrorHtml() end

		# Provides information in plain-text format about the last method/property called. If a method call
		# returns a value indicating failure, or behaves unexpectedly, examine this property to get more
		# information.
		#
		# @param ckStr [CkString]
		#
		# @return [String]
		def get_LastErrorText(ckStr) end

		# Provides information in plain-text format about the last method/property called. If a method call
		# returns a value indicating failure, or behaves unexpectedly, examine this property to get more
		# information.
		#
		# @return [String]
		def lastErrorText() end

		# Provides information in XML format about the last method/property called. If a method call returns a
		# value indicating failure, or behaves unexpectedly, examine this property to get more information.
		#
		# @param ckStr [CkString]
		#
		# @return [String]
		def get_LastErrorXml(ckStr) end

		# Provides information in XML format about the last method/property called. If a method call returns a
		# value indicating failure, or behaves unexpectedly, examine this property to get more information.
		#
		# @return [String]
		def lastErrorXml() end

		# Indicate whether the last method call succeeded or failed. A value of _TRUE_ indicates success, a
		# value of _FALSE_ indicates failure. This property is automatically set for method calls. It is not
		# modified by property accesses. The property is automatically set to indicate success for the
		# following types of method calls:
		# 
		# Any method that returns a string.
		# Any method
		# returning a Chilkat object, binary bytes, or a date/time.
		# Any method returning a standard
		# boolean status value where success = _TRUE_ and failure = _FALSE_.
		# Any method returning an
		# integer where failure is defined by a return value less than zero.
		# 
		# Note: Methods that do
		# not fit the above requirements will always set this property equal to _TRUE_. For example, a method
		# that returns no value (such as a "void" in C++) will technically always succeed.
		#
		# @return [Boolean]
		def get_LastMethodSuccess() end

		# Indicate whether the last method call succeeded or failed. A value of _TRUE_ indicates success, a
		# value of _FALSE_ indicates failure. This property is automatically set for method calls. It is not
		# modified by property accesses. The property is automatically set to indicate success for the
		# following types of method calls:
		# 
		# Any method that returns a string.
		# Any method
		# returning a Chilkat object, binary bytes, or a date/time.
		# Any method returning a standard
		# boolean status value where success = _TRUE_ and failure = _FALSE_.
		# Any method returning an
		# integer where failure is defined by a return value less than zero.
		# 
		# Note: Methods that do
		# not fit the above requirements will always set this property equal to _TRUE_. For example, a method
		# that returns no value (such as a "void" in C++) will technically always succeed.
		#
		# @param newval [Boolean]
		def put_LastMethodSuccess(newval) end

		# The string return value of the last (string returning) method called. Only available if
		# Chilkat.Global.KeepStringResult is set to _TRUE_. This provides a means for obtaining large string
		# results in the SQL Server environment (where limitations exist in getting long strings returned by
		# method calls, but where temp tables can be used for string properties).
		#
		# @param ckStr [CkString]
		#
		# @return [String]
		def get_LastStringResult(ckStr) end

		# The string return value of the last (string returning) method called. Only available if
		# Chilkat.Global.KeepStringResult is set to _TRUE_. This provides a means for obtaining large string
		# results in the SQL Server environment (where limitations exist in getting long strings returned by
		# method calls, but where temp tables can be used for string properties).
		#
		# @return [String]
		def lastStringResult() end

		# The length, in characters, of the string contained in the LastStringResult property.
		#
		# @return [Bignum]
		def get_LastStringResultLen() end

		# The value of the "micalg" attribute of the Content-Type header field. For example, if the
		# Content-Type header is this:
		# 
		# Content-Type: multipart/signed;
		# protocol="application/x-pkcs7-signature"; micalg=sha1; 
		#
		# boundary="------------ms000908010507020408060303"
		# 
		# then the value of the Micalg property
		# is "sha".
		# 
		# Note: The micalg attribute is only present in PKCS7 signed MIME. Setting the
		# Micalg property has the effect of choosing the hash algorithm used w/ signing. Possible choices are
		# "sha1", "md5", "sha256", "sha384", and "sha512". However, it is preferable to set the signing hash
		# algorithm by setting the SigningHashAlg property instead.
		#
		# @param ckStr [CkString]
		#
		# @return [String]
		def get_Micalg(ckStr) end

		# The value of the "micalg" attribute of the Content-Type header field. For example, if the
		# Content-Type header is this:
		# 
		# Content-Type: multipart/signed;
		# protocol="application/x-pkcs7-signature"; micalg=sha1; 
		#
		# boundary="------------ms000908010507020408060303"
		# 
		# then the value of the Micalg property
		# is "sha".
		# 
		# Note: The micalg attribute is only present in PKCS7 signed MIME. Setting the
		# Micalg property has the effect of choosing the hash algorithm used w/ signing. Possible choices are
		# "sha1", "md5", "sha256", "sha384", and "sha512". However, it is preferable to set the signing hash
		# algorithm by setting the SigningHashAlg property instead.
		#
		# @param newval [String]
		def put_Micalg(newval) end

		# The value of the "micalg" attribute of the Content-Type header field. For example, if the
		# Content-Type header is this:
		# 
		# Content-Type: multipart/signed;
		# protocol="application/x-pkcs7-signature"; micalg=sha1; 
		#
		# boundary="------------ms000908010507020408060303"
		# 
		# then the value of the Micalg property
		# is "sha".
		# 
		# Note: The micalg attribute is only present in PKCS7 signed MIME. Setting the
		# Micalg property has the effect of choosing the hash algorithm used w/ signing. Possible choices are
		# "sha1", "md5", "sha256", "sha384", and "sha512". However, it is preferable to set the signing hash
		# algorithm by setting the SigningHashAlg property instead.
		#
		# @return [String]
		def micalg() end

		# The value of the "micalg" attribute of the Content-Type header field. For example, if the
		# Content-Type header is this:
		# 
		# Content-Type: multipart/signed;
		# protocol="application/x-pkcs7-signature"; micalg=sha1; 
		#
		# boundary="------------ms000908010507020408060303"
		# 
		# then the value of the Micalg property
		# is "sha".
		# 
		# Note: The micalg attribute is only present in PKCS7 signed MIME. Setting the
		# Micalg property has the effect of choosing the hash algorithm used w/ signing. Possible choices are
		# "sha1", "md5", "sha256", "sha384", and "sha512". However, it is preferable to set the signing hash
		# algorithm by setting the SigningHashAlg property instead.
		#
		# @param newval [String]
		def put_Micalg(newval) end

		# The value of the "name" attribute of the Content-Type header field. For example, if the Content-Type
		# header is this:
		# 
		# Content-Type: image/gif; name="starfish.gif"
		# 
		# then the
		# value of the Name property is "starfish.gif".
		#
		# @param ckStr [CkString]
		#
		# @return [String]
		def get_Name(ckStr) end

		# The value of the "name" attribute of the Content-Type header field. For example, if the Content-Type
		# header is this:
		# 
		# Content-Type: image/gif; name="starfish.gif"
		# 
		# then the
		# value of the Name property is "starfish.gif".
		#
		# @param newval [String]
		def put_Name(newval) end

		# The value of the "name" attribute of the Content-Type header field. For example, if the Content-Type
		# header is this:
		# 
		# Content-Type: image/gif; name="starfish.gif"
		# 
		# then the
		# value of the Name property is "starfish.gif".
		#
		# @return [String]
		def name() end

		# The value of the "name" attribute of the Content-Type header field. For example, if the Content-Type
		# header is this:
		# 
		# Content-Type: image/gif; name="starfish.gif"
		# 
		# then the
		# value of the Name property is "starfish.gif".
		#
		# @param newval [String]
		def put_Name(newval) end

		# The number of certificates found when decrypting S/MIME. This property is set after UnwrapSecurity
		# is called.
		#
		# @return [Bignum]
		def get_NumEncryptCerts() end

		# The number of header fields. Header field names and values can be retrieved by index (starting at 0)
		# by calling GetHeaderFieldName and GetHeaderFieldValue.
		#
		# @return [Bignum]
		def get_NumHeaderFields() end

		# MIME messages are composed of parts in a tree structure. The NumParts property contains the number
		# of direct children. To traverse an entire MIME tree, one would recursively descend the tree
		# structure by iterating from 0 to NumParts-1, calling GetPart to get each direct child MIME object.
		# The traversal would continue by iterating over each child's parts, and so on.
		#
		# @return [Bignum]
		def get_NumParts() end

		# The number of certificates found when verifying signature(s). This property is set after
		# UnwrapSecurity is called.
		#
		# @return [Bignum]
		def get_NumSignerCerts() end

		# When the MIME is encrypted (using PKCS7 public-key encryption), this selects the underlying
		# symmetric encryption algorithm. Possible values are: "aes", "des", "3des", and "rc2". The default
		# value is "aes".
		#
		# @param ckStr [CkString]
		#
		# @return [String]
		def get_Pkcs7CryptAlg(ckStr) end

		# When the MIME is encrypted (using PKCS7 public-key encryption), this selects the underlying
		# symmetric encryption algorithm. Possible values are: "aes", "des", "3des", and "rc2". The default
		# value is "aes".
		#
		# @param newval [String]
		def put_Pkcs7CryptAlg(newval) end

		# When the MIME is encrypted (using PKCS7 public-key encryption), this selects the underlying
		# symmetric encryption algorithm. Possible values are: "aes", "des", "3des", and "rc2". The default
		# value is "aes".
		#
		# @return [String]
		def pkcs7CryptAlg() end

		# When the MIME is encrypted (using PKCS7 public-key encryption), this selects the underlying
		# symmetric encryption algorithm. Possible values are: "aes", "des", "3des", and "rc2". The default
		# value is "aes".
		#
		# @param newval [String]
		def put_Pkcs7CryptAlg(newval) end

		# When the MIME is encrypted (using PKCS7 public-key encryption), this selects the key length of the
		# underlying symmetric encryption algorithm. The possible values allowed depend on the Pkcs7CryptAlg
		# property. For "aes", the key length may be 128, 192, or 256. For "3des" the key length must be 192.
		# For "des" the key length must be 40. For "rc2" the key length can be 40, 56, 64, or 128.
		#
		# @return [Bignum]
		def get_Pkcs7KeyLength() end

		# When the MIME is encrypted (using PKCS7 public-key encryption), this selects the key length of the
		# underlying symmetric encryption algorithm. The possible values allowed depend on the Pkcs7CryptAlg
		# property. For "aes", the key length may be 128, 192, or 256. For "3des" the key length must be 192.
		# For "des" the key length must be 40. For "rc2" the key length can be 40, 56, 64, or 128.
		#
		# @param newval [Bignum]
		def put_Pkcs7KeyLength(newval) end

		# The value of the "protocol" attribute of the Content-Type header field. For example, if the
		# Content-Type header is this:
		# 
		# Content-Type: multipart/signed;
		# protocol="application/x-pkcs7-signature"; micalg=sha1; 
		#
		# boundary="------------ms000908010507020408060303"
		# 
		# then the value of the Protocol
		# property is "application/x-pkcs7-signature".
		#
		# @param ckStr [CkString]
		#
		# @return [String]
		def get_Protocol(ckStr) end

		# The value of the "protocol" attribute of the Content-Type header field. For example, if the
		# Content-Type header is this:
		# 
		# Content-Type: multipart/signed;
		# protocol="application/x-pkcs7-signature"; micalg=sha1; 
		#
		# boundary="------------ms000908010507020408060303"
		# 
		# then the value of the Protocol
		# property is "application/x-pkcs7-signature".
		#
		# @param newval [String]
		def put_Protocol(newval) end

		# The value of the "protocol" attribute of the Content-Type header field. For example, if the
		# Content-Type header is this:
		# 
		# Content-Type: multipart/signed;
		# protocol="application/x-pkcs7-signature"; micalg=sha1; 
		#
		# boundary="------------ms000908010507020408060303"
		# 
		# then the value of the Protocol
		# property is "application/x-pkcs7-signature".
		#
		# @return [String]
		def protocol() end

		# The value of the "protocol" attribute of the Content-Type header field. For example, if the
		# Content-Type header is this:
		# 
		# Content-Type: multipart/signed;
		# protocol="application/x-pkcs7-signature"; micalg=sha1; 
		#
		# boundary="------------ms000908010507020408060303"
		# 
		# then the value of the Protocol
		# property is "application/x-pkcs7-signature".
		#
		# @param newval [String]
		def put_Protocol(newval) end

		# Selects the underlying hash algorithm used when creating signed (PKCS7) MIME. Possible values are
		# "sha1", "sha256", "sha384", "sha512", "md5", and "md2".
		#
		# @param ckStr [CkString]
		#
		# @return [String]
		def get_SigningHashAlg(ckStr) end

		# Selects the underlying hash algorithm used when creating signed (PKCS7) MIME. Possible values are
		# "sha1", "sha256", "sha384", "sha512", "md5", and "md2".
		#
		# @param newval [String]
		def put_SigningHashAlg(newval) end

		# Selects the underlying hash algorithm used when creating signed (PKCS7) MIME. Possible values are
		# "sha1", "sha256", "sha384", "sha512", "md5", and "md2".
		#
		# @return [String]
		def signingHashAlg() end

		# Selects the underlying hash algorithm used when creating signed (PKCS7) MIME. Possible values are
		# "sha1", "sha256", "sha384", "sha512", "md5", and "md2".
		#
		# @param newval [String]
		def put_SigningHashAlg(newval) end

		# Controls whether extra (informative) header fields are added to the MIME message when unwrapping
		# security.
		#
		# @return [Boolean]
		def get_UnwrapExtras() end

		# Controls whether extra (informative) header fields are added to the MIME message when unwrapping
		# security.
		#
		# @param newval [Boolean]
		def put_UnwrapExtras(newval) end

		# Controls whether the boilerplate text "This is a multi-part message in MIME format." is used as the
		# body content of a multipart MIME part.
		#
		# @return [Boolean]
		def get_UseMmDescription() end

		# Controls whether the boilerplate text "This is a multi-part message in MIME format." is used as the
		# body content of a multipart MIME part.
		#
		# @param newval [Boolean]
		def put_UseMmDescription(newval) end

		# If _TRUE_, then the Content-Type header fields created by Chilkat will use "x-pkcs7" instead of
		# simply "pkcs7" . For example:
		# 
		# Content-Type:
		# multipart/signed;
		# 	boundary="----=_NextPart_af8_0422_dbec3a60.7178e470";
		# 	protocol="application/x-pkcs7-signature";
		# micalg=sha1
		# 
		# or
		# 
		# Content-Type: application/x-pkcs7-mime;
		# name="smime.p7m"
		# 
		# If _FALSE_, then the "pcks7" is used. For
		# example:
		# 
		# Content-Type:
		# multipart/signed;
		# 	boundary="----=_NextPart_af8_0422_dbec3a60.7178e470";
		# 	protocol="application/pkcs7-signature";
		# micalg=sha1
		# 
		# or
		# 
		# Content-Type: application/pkcs7-mime;
		# name="smime.p7m"
		# 
		# 
		# The default value of this property is _TRUE_, meaning that "x-"
		# is used by default.
		#
		# @return [Boolean]
		def get_UseXPkcs7() end

		# If _TRUE_, then the Content-Type header fields created by Chilkat will use "x-pkcs7" instead of
		# simply "pkcs7" . For example:
		# 
		# Content-Type:
		# multipart/signed;
		# 	boundary="----=_NextPart_af8_0422_dbec3a60.7178e470";
		# 	protocol="application/x-pkcs7-signature";
		# micalg=sha1
		# 
		# or
		# 
		# Content-Type: application/x-pkcs7-mime;
		# name="smime.p7m"
		# 
		# If _FALSE_, then the "pcks7" is used. For
		# example:
		# 
		# Content-Type:
		# multipart/signed;
		# 	boundary="----=_NextPart_af8_0422_dbec3a60.7178e470";
		# 	protocol="application/pkcs7-signature";
		# micalg=sha1
		# 
		# or
		# 
		# Content-Type: application/pkcs7-mime;
		# name="smime.p7m"
		# 
		# 
		# The default value of this property is _TRUE_, meaning that "x-"
		# is used by default.
		#
		# @param newval [Boolean]
		def put_UseXPkcs7(newval) end

		# When set to _TRUE_, all "const char *" arguments are interpreted as utf-8 strings. If set to _FALSE_
		# (the default), then "const char *" arguments are interpreted as ANSI strings.
		# 
		# Also,
		# when set to _TRUE_, and Chilkat method returning a "const char *" is returning the utf-8
		# representation. If set to _FALSE_, all "const char *" return values are ANSI strings.
		#
		# @return [Boolean]
		def get_Utf8() end

		# When set to _TRUE_, all "const char *" arguments are interpreted as utf-8 strings. If set to _FALSE_
		# (the default), then "const char *" arguments are interpreted as ANSI strings.
		# 
		# Also,
		# when set to _TRUE_, and Chilkat method returning a "const char *" is returning the utf-8
		# representation. If set to _FALSE_, all "const char *" return values are ANSI strings.
		#
		# @param newval [Boolean]
		def put_Utf8(newval) end

		# If set to _TRUE_, then the contents of LastErrorText (or LastErrorXml, or LastErrorHtml) may contain
		# more verbose information. The default value is _FALSE_. Verbose logging should only be used for
		# debugging. The potentially large quantity of logged information may adversely affect peformance.
		#
		# @return [Boolean]
		def get_VerboseLogging() end

		# If set to _TRUE_, then the contents of LastErrorText (or LastErrorXml, or LastErrorHtml) may contain
		# more verbose information. The default value is _FALSE_. Verbose logging should only be used for
		# debugging. The potentially large quantity of logged information may adversely affect peformance.
		#
		# @param newval [Boolean]
		def put_VerboseLogging(newval) end

		# Version of the component/library, such as "9.5.0.63"
		#
		# @param ckStr [CkString]
		#
		# @return [String]
		def get_Version(ckStr) end

		# Version of the component/library, such as "9.5.0.63"
		#
		# @return [String]
		def version() end


		# Method: AddContentLength
		#
		# Computes the size of the MIME body and adds a Content-Length header field with the computed value.
		# If the MIME body is non-multipart, the Content-Length is just the size of the content. If the MIME
		# is multipart, then the Content-Length is the sum of all the sub-parts. Calling this method more than
		# once causes the Content-Length header to be re-computed and updated.
		#
		#
		# @return [nil]
		def AddContentLength()
			# ...
		end


		# Method: AddDecryptCert
		#
		# Makes a certificate available for decrypting if needed by methods that decrypt, such as
		# UnwrapSecurity. This method may be called multiple times to make more than one certificate (and it's
		# private key) available. Alternative methods for making certificates available are UseCertVault,
		# AddPfxSourceFile, and AddPfxSourceData.
		#
		# @param cert [CkCert]
		#
		# @return [Boolean]
		def AddDecryptCert(cert)
			# ...
		end


		# Method: AddDetachedSignature
		#
		# Signs the message using the certificate provided. If successful, the message is converted to
		# "multipart/signed" and the original message will be contained in the first sub-part.
		#
		# @param cert [CkCert]
		#
		# @return [Boolean]
		def AddDetachedSignature(cert)
			# ...
		end


		# Method: AddDetachedSignature2
		#
		# Same as AddDetachedSignature, except an extra argument is provided to control whether header fields
		# from the calling MIME object are transferred to the content part of the multipart/signed object.
		# This method transforms the calling object into a multipart/signed MIME with two sub-parts. The first
		# contains the original content of the calling object, and the second contains the digital signature.
		#
		# @param cert [CkCert]
		# @param transferHeaderFields [Boolean]
		#
		# @return [Boolean]
		def AddDetachedSignature2(cert, transferHeaderFields)
			# ...
		end


		# Method: AddDetachedSignaturePk
		#
		# Adds a detached signature using a certificate and it's associated private key. This method would be
		# used when the private key is external to the certificate -- for example, if a PFX/P12 file is not
		# used, but instead a pair of .cer and .pem files are used (one for the certificate and one for the
		# associated private key).
		#
		# @param cert [CkCert]
		# @param privateKey [CkPrivateKey]
		#
		# @return [Boolean]
		def AddDetachedSignaturePk(cert, privateKey)
			# ...
		end


		# Method: AddDetachedSignaturePk2
		#
		# Same as AddDetachedSignaturePk, except an extra argument is provided to control whether header
		# fields from the calling MIME object are transferred to the content part of the multipart/signed
		# object. This method transforms the calling object into a multipart/signed MIME with two sub-parts.
		# The first contains the original content of the calling object, and the second contains the digital
		# signature.
		#
		# @param cert [CkCert]
		# @param privateKey [CkPrivateKey]
		# @param transferHeaderFields [Boolean]
		#
		# @return [Boolean]
		def AddDetachedSignaturePk2(cert, privateKey, transferHeaderFields)
			# ...
		end


		# Method: AddEncryptCert
		#
		# Adds a certificate to the object's internal list of certificates to be used when the EncryptN method
		# is called. (See the EncryptN method for more information.) The internal list may be cleared by
		# calling ClearEncryptCerts.
		#
		# @param cert [CkCert]
		#
		# @return [Boolean]
		def AddEncryptCert(cert)
			# ...
		end


		# Method: AddHeaderField
		#
		# Adds a header field to the MIME.
		#
		# @param name [String]
		# @param value [String]
		#
		# @return [Boolean]
		def AddHeaderField(name, value)
			# ...
		end


		# Method: AddPfxSourceData
		#
		# Adds a PFX to the object's internal list of sources to be searched for certificates and private keys
		# when decrypting . Multiple PFX sources can be added by calling this method once for each. (On the
		# Windows operating system, the registry-based certificate stores are also automatically searched, so
		# it is commonly not required to explicitly add PFX sources.)
		# 
		# The ARG1 contains the bytes
		# of a PFX file (also known as PKCS12 or .p12).
		#
		# @param pfxFileData [CkByteData]
		# @param pfxPassword [String]
		#
		# @return [Boolean]
		def AddPfxSourceData(pfxFileData, pfxPassword)
			# ...
		end


		# Method: AddPfxSourceFile
		#
		# Adds a PFX file to the object's internal list of sources to be searched for certificates and private
		# keys when decrypting. Multiple PFX files can be added by calling this method once for each. (On the
		# Windows operating system, the registry-based certificate stores are also automatically searched, so
		# it is commonly not required to explicitly add PFX sources.)
		# 
		# The ARG1 contains the bytes
		# of a PFX file (also known as PKCS12 or .p12).
		#
		# @param pfxFilePath [String]
		# @param password [String]
		#
		# @return [Boolean]
		def AddPfxSourceFile(pfxFilePath, password)
			# ...
		end


		# Method: AppendPart
		#
		# Appends a MIME message to the sub-parts of this message. Arbitrarily complex messages with unlimited
		# nesting levels can be created. If the calling Mime object is not already multipart, it is
		# automatically converted to multipart/mixed first.
		#
		# @param mime [CkMime]
		#
		# @return [Boolean]
		def AppendPart(mime)
			# ...
		end


		# Method: AppendPartFromFile
		#
		# Loads a file and creates a Mime message object using the file extension to determine the content
		# type, and adds it as a sub-part to the calling object.
		#
		# @param filename [String]
		#
		# @return [Boolean]
		def AppendPartFromFile(filename)
			# ...
		end


		# Method: AsnBodyToXml
		#
		# When the body of a MIME part contains PKCS7 (ASN.1 in DER format, base64-encoded), this method can
		# be used to convert the ASN.1 to an XML format for inspection. Here is an example of how an ASN.1
		# body might look:
		# 
		# Content-Type: application/x-pkcs7-mime;
		# 	name="smime.p7m";
		# smime-type="signed-data"
		# Content-Transfer-Encoding: base64
		# Content-Disposition:
		# attachment;
		# filename="smime.p7m"
		# 
		# MIIXXAYJKoZIhvcNAQcCoIIXTTCCF0kCAQExCzAJBgUrDgMCGgUAMFoGCSqGSIb3DQEHAaBNBEtD
		# b250ZW50LVR5cGU6IHRleHQvcGxhaW4NCkNvbnRlbnQtVHJhbnNmZXItRW5jb2Rpbmc6IDdiaXQN
		# Cg0KdGhpcyBpcyBhIHRlc3SgghI/MIIE3jCCA8agAwIBAgICAwEwDQYJKoZIhvcNAQEFBQAwYzEL
		# ...
		# 
		# The
		# XML produced would look something like this:
		# 
		# _LT_?xml version="1.0" encoding="utf-8"
		# ?>
		# _LT_sequence>
		# _LT_oid>1.2.840.113549.1.7.2_LT_/oid>
		# _LT_contextSpecific tag="0"
		# constructed="1">
		# _LT_sequence>
		# _LT_int>01_LT_/int>
		# _LT_set>
		# _LT_sequence>
		#
		# _LT_oid>1.3.14.3.2.26_LT_/oid>
		# _LT_null />
		# _LT_/sequence>
		# _LT_/set>
		#
		# _LT_sequence>
		# _LT_oid>1.2.840.113549.1.7.1_LT_/oid>
		# _LT_contextSpecific tag="0"
		# constructed="1">
		# ...
		#
		#
		# @param outStr [CkString]
		#
		# @return [Boolean]
		def AsnBodyToXml(outStr)
			# ...
		end


		# Method: AsnBodyToXml
		#
		# When the body of a MIME part contains PKCS7 (ASN.1 in DER format, base64-encoded), this method can
		# be used to convert the ASN.1 to an XML format for inspection. Here is an example of how an ASN.1
		# body might look:
		# 
		# Content-Type: application/x-pkcs7-mime;
		# 	name="smime.p7m";
		# smime-type="signed-data"
		# Content-Transfer-Encoding: base64
		# Content-Disposition:
		# attachment;
		# filename="smime.p7m"
		# 
		# MIIXXAYJKoZIhvcNAQcCoIIXTTCCF0kCAQExCzAJBgUrDgMCGgUAMFoGCSqGSIb3DQEHAaBNBEtD
		# b250ZW50LVR5cGU6IHRleHQvcGxhaW4NCkNvbnRlbnQtVHJhbnNmZXItRW5jb2Rpbmc6IDdiaXQN
		# Cg0KdGhpcyBpcyBhIHRlc3SgghI/MIIE3jCCA8agAwIBAgICAwEwDQYJKoZIhvcNAQEFBQAwYzEL
		# ...
		# 
		# The
		# XML produced would look something like this:
		# 
		# _LT_?xml version="1.0" encoding="utf-8"
		# ?>
		# _LT_sequence>
		# _LT_oid>1.2.840.113549.1.7.2_LT_/oid>
		# _LT_contextSpecific tag="0"
		# constructed="1">
		# _LT_sequence>
		# _LT_int>01_LT_/int>
		# _LT_set>
		# _LT_sequence>
		#
		# _LT_oid>1.3.14.3.2.26_LT_/oid>
		# _LT_null />
		# _LT_/sequence>
		# _LT_/set>
		#
		# _LT_sequence>
		# _LT_oid>1.2.840.113549.1.7.1_LT_/oid>
		# _LT_contextSpecific tag="0"
		# constructed="1">
		# ...
		#
		#
		#
		# @return [String]
		def asnBodyToXml()
			# ...
		end


		# Method: ClearEncryptCerts
		#
		# Clears the internal list of certificates added by previous calls to the AddEncryptCert method. (See
		# the EncryptN method for information about encrypting using multiple certificates.)
		#
		#
		# @return [nil]
		def ClearEncryptCerts()
			# ...
		end


		# Method: ContainsEncryptedParts
		#
		# Returns _TRUE_ if the MIME message contains encrypted parts.
		# 
		# Note: This method examines
		# the MIME as-is. If UnwrapSecurity is called and it is successful, then the MIME should no longer
		# contain encrypted parts, and this method would return 0.
		# 
		# Note: If a signed MIME message
		# is then encrypted, then it is not possible to know that the MIME is both encrypted and signed until
		# UnwrapSecurity is called. (In other words, it is not possible to know the contents of the encrypted
		# MIME until it is decrypted.) Therefore, the ContainsSignedParts method would return _FALSE_.
		#
		#
		# @return [Boolean]
		def ContainsEncryptedParts()
			# ...
		end


		# Method: ContainsSignedParts
		#
		# Returns _TRUE_ if the MIME message contains signed parts.
		# 
		# Note: This method examines
		# the MIME as-is. If UnwrapSecurity is called and it is successful, then the MIME should no longer
		# contain signed parts, and this method would return 0.
		# 
		# Note: If a signed MIME message is
		# then encrypted, then it is not possible to know that the MIME is both encrypted and signed until
		# UnwrapSecurity is called. (In other words, it is not possible to know the contents of the encrypted
		# MIME until it is decrypted.) Therefore, the ContainsSignedParts method would return
		# _FALSE_.
		# 
		# Note: The same concept also applies to opaque signatures, such as with the
		# MIME produced by calling ConvertToSigned.
		#
		#
		# @return [Boolean]
		def ContainsSignedParts()
			# ...
		end


		# Method: Convert8Bit
		#
		# Changes the content-transfer-encoding to "base64" for all 8bit or binary MIME subparts. This allows
		# for the MIME to be exported as a string via the GetMime method.
		#
		#
		# @return [nil]
		def Convert8Bit()
			# ...
		end


		# Method: ConvertToMultipartAlt
		#
		# Converts existing MIME to a multipart/alternative. This is accomplished by creating a new outermost
		# multipart/alternative MIME part. The existing MIME is moved into the 1st (and only) sub-part of the
		# new multipart/alternative enclosure. Header fields from the original top-level MIME part are
		# transferred to the new top-level multipart/alternative header, except for Content-Type,
		# Content-Transfer-Encoding, and Content-Disposition. For example, the following simple plain-text
		# MIME is converted as follows:
		# Original: 
		# 
		# MIME-Version: 1.0
		# Date: Sun, 11
		# Aug 2013 11:18:44 -0500
		# Message-ID: 
		# Content-Type:
		# text/plain
		# Content-Transfer-Encoding: quoted-printable
		# X-Priority: 3
		# (Normal)
		# Subject: this is the subject.
		# From: "Chilkat Software" 
		# To: "Chilkat
		# Sales" 
		# 
		# This is the plain-text body.
		# 
		# After
		# Converting:
		# 
		# MIME-Version: 1.0
		# Date: Sun, 11 Aug 2013 11:18:44
		# -0500
		# Message-ID: 
		# X-Priority: 3 (Normal)
		# Subject: this is the
		# subject.
		# From: "Chilkat Software" 
		# To: "Chilkat Sales" 
		# Content-Type:
		# multipart/alternative;
		# 	boundary="------------040101040804050401050400_.ALT"
		# 
		# --------------040101040804050401050400_.ALT
		# Content-Type:
		# text/plain
		# Content-Transfer-Encoding: quoted-printable
		# 
		# This is the plain-text
		# body.
		# --------------040101040804050401050400_.ALT--
		# 
		#
		#
		#
		# @return [Boolean]
		def ConvertToMultipartAlt()
			# ...
		end


		# Method: ConvertToMultipartMixed
		#
		# Converts existing MIME to a multipart/mixed. This is accomplished by creating a new outermost
		# multipart/mixed MIME part. The existing MIME is moved into the 1st (and only) sub-part of the new
		# multipart/mixed enclosure. Header fields from the original top-level MIME part are transferred to
		# the new top-level multipart/mixed header, except for Content-Type, Content-Transfer-Encoding, and
		# Content-Disposition. For example, the following simple plain-text MIME is converted as
		# follows:
		# Original: 
		# 
		# MIME-Version: 1.0
		# Date: Sun, 11 Aug 2013 11:27:04
		# -0500
		# Message-ID: 
		# Content-Type: text/plain
		# Content-Transfer-Encoding:
		# quoted-printable
		# X-Priority: 3 (Normal)
		# Subject: this is the subject.
		# From:
		# "Chilkat Software" 
		# To: "Chilkat Sales" 
		# 
		# This is the plain-text
		# body.
		# 
		# After Converting:
		# 
		# MIME-Version: 1.0
		# Date: Sun, 11 Aug 2013
		# 11:27:04 -0500
		# Message-ID: 
		# X-Priority: 3 (Normal)
		# Subject: this is the
		# subject.
		# From: "Chilkat Software" 
		# To: "Chilkat Sales" 
		# Content-Type:
		# multipart/mixed;
		# 	boundary="------------050508060709030908040207"
		# 
		# --------------050508060709030908040207
		# Content-Type:
		# text/plain
		# Content-Transfer-Encoding: quoted-printable
		# 
		# This is the plain-text
		# body.
		# --------------050508060709030908040207--
		#
		#
		#
		# @return [Boolean]
		def ConvertToMultipartMixed()
			# ...
		end


		# Method: ConvertToSigned
		#
		# Digitally signs a MIME message. The MIME is converted to an application/x-pkcs7-mime which is a
		# PKCS7 signature that includes both the original MIME message and the signature. This is different
		# than AddDetachedSignature, where the signature is appended to the MIME.
		# 
		# Note: This is
		# commonly referred to as an "opaque" signature.
		#
		# @param cert [CkCert]
		#
		# @return [Boolean]
		def ConvertToSigned(cert)
			# ...
		end


		# Method: ConvertToSignedPk
		#
		# Digitally signs the MIME to convert it to an "opaque" signed message using a certificate and it's
		# associated private key. This method would be used when the private key is external to the
		# certificate -- for example, if a PFX/P12 file is not used, but instead a pair of .cer and .pem files
		# are used (one for the certificate and one for the associated private key).
		#
		# @param cert [CkCert]
		# @param privateKey [CkPrivateKey]
		#
		# @return [Boolean]
		def ConvertToSignedPk(cert, privateKey)
			# ...
		end


		# Method: Decrypt
		#
		# Decrypts PKCS7 encrypted MIME (also known as S/MIME). Information about the certificates required
		# for decryption is always embedded within PKCS7 encrypted MIME. This method will automatically find
		# and use the certificate + private key required from three possible sources:
		# 
		# PFX files
		# that were provided in one or more calls to AddPfxSourceData or AddPfxSourceFile.
		# Certificates
		# found in an XML certificate vault provided by calling the UseCertVault method.
		# (On Windows
		# systems) Certificates found in the system's registry-based certificate stores.
		#
		#
		#
		# @return [Boolean]
		def Decrypt()
			# ...
		end


		# Method: Decrypt2
		#
		# The same as Decrypt, but useful when the certificate and private key are available in separate files
		# (as opposed to a single file such as a .pfx/.p12).
		#
		# @param cert [CkCert]
		# @param privateKey [CkPrivateKey]
		#
		# @return [Boolean]
		def Decrypt2(cert, privateKey)
			# ...
		end


		# Method: DecryptUsingCert
		#
		# Decrypts PKCS7 encrypted MIME (also known as S/MIME) using a specific certificate.
		#
		# @param cert [CkCert]
		#
		# @return [Boolean]
		def DecryptUsingCert(cert)
			# ...
		end


		# Method: DecryptUsingPfxData
		#
		# Decrypts MIME using a specific PFX ( also known as PKCS12, which is a file format commonly used to
		# store private keys with accompanying public key certificates, protected with a password-based
		# symmetric key). This method allows the bytes of the PKCS12 file to be passed directly, thus allowing
		# PKCS12's to be persisted and retrieved from non-file-based locations, such as in LDAP or a database.
		#
		# @param pfxData [CkByteData]
		# @param password [String]
		#
		# @return [Boolean]
		def DecryptUsingPfxData(pfxData, password)
			# ...
		end


		# Method: DecryptUsingPfxFile
		#
		# Decrypts MIME using a specific PFX file (also known as PKCS12) as the source for any required
		# certificates and private keys. (Note: .pfx and .p12 files are both PKCS12 format.)
		#
		# @param pfxFilePath [String]
		# @param pfxPassword [String]
		#
		# @return [Boolean]
		def DecryptUsingPfxFile(pfxFilePath, pfxPassword)
			# ...
		end


		# Method: Encrypt
		#
		# Encrypts the MIME to create PKCS7 encrypted MIME. A digital certificate (which always contains a
		# public-key) is used to encrypt.
		#
		# @param cert [CkCert]
		#
		# @return [Boolean]
		def Encrypt(cert)
			# ...
		end


		# Method: EncryptN
		#
		# Encrypt MIME using any number of digital certificates. Each certificate to be used must first be
		# added by calling AddEncryptCert (once per certificate). See the example code below:
		#
		#
		# @return [Boolean]
		def EncryptN()
			# ...
		end


		# Method: ExtractPartsToFiles
		#
		# Recursively descends through the parts of a MIME message and extracts all parts having a filename to
		# a file. The files are created in ARG1. Returns a (Ck)StringArray object containing the names of the
		# files created. The filenames are obtained from the "filename" attribute of the content-disposition
		# header. If a filename does not exist, then the MIME part is not saved to a file.
		#
		# @param dirPath [String]
		#
		# @return [CkStringArray]
		def ExtractPartsToFiles(dirPath)
			# ...
		end


		# Method: FindIssuer
		#
		# Finds and returns the issuer certificate. If the certificate is a root or self-issued, then the
		# certificate returned is a copy of the caller certificate.
		#
		# @param cert [CkCert]
		#
		# @return [CkCert]
		def FindIssuer(cert)
			# ...
		end


		# Method: GetBodyBinary
		#
		# Returns the body of the MIME message as a block of binary data. The body is automatically converted
		# from its encoding type, such as base64 or quoted-printable, before being returned.
		#
		# @param outData [CkByteData]
		#
		# @return [Boolean]
		def GetBodyBinary(outData)
			# ...
		end


		# Method: GetBodyDecoded
		#
		# Returns the body of the MIME message as a string. The body is automatically converted from its
		# encoding type, such as base64 or quoted-printable, before being returned.
		#
		# @param outStr [CkString]
		#
		# @return [Boolean]
		def GetBodyDecoded(outStr)
			# ...
		end


		# Method: GetBodyDecoded
		#
		# Returns the body of the MIME message as a string. The body is automatically converted from its
		# encoding type, such as base64 or quoted-printable, before being returned.
		#
		#
		# @return [String]
		def getBodyDecoded()
			# ...
		end


		# Method: GetBodyEncoded
		#
		# Returns the body of the MIME message as a String. The body is explicitly not decoded from it's
		# encoding type, so if it was represented in Base64, you will get the Base64 encoded body, as an
		# example.
		#
		# @param outStr [CkString]
		#
		# @return [Boolean]
		def GetBodyEncoded(outStr)
			# ...
		end


		# Method: GetBodyEncoded
		#
		# Returns the body of the MIME message as a String. The body is explicitly not decoded from it's
		# encoding type, so if it was represented in Base64, you will get the Base64 encoded body, as an
		# example.
		#
		#
		# @return [String]
		def getBodyEncoded()
			# ...
		end


		# Method: GetEncryptCert
		#
		# Returns the Nth certificate found when decrypting. The EncryptCerts property contains the number of
		# certificates.
		#
		# @param index [Fixnum]
		#
		# @return [CkCert]
		def GetEncryptCert(index)
			# ...
		end


		# Method: GetEntireBody
		#
		# Returns the entire MIME body, including all sub-parts.
		#
		# @param outStr [CkString]
		#
		# @return [Boolean]
		def GetEntireBody(outStr)
			# ...
		end


		# Method: GetEntireBody
		#
		# Returns the entire MIME body, including all sub-parts.
		#
		#
		# @return [String]
		def getEntireBody()
			# ...
		end


		# Method: GetEntireHead
		#
		# Returns the MIME header.
		#
		# @param outStr [CkString]
		#
		# @return [Boolean]
		def GetEntireHead(outStr)
			# ...
		end


		# Method: GetEntireHead
		#
		# Returns the MIME header.
		#
		#
		# @return [String]
		def getEntireHead()
			# ...
		end


		# Method: GetHeaderField
		#
		# Returns the value of a MIME header field. ARG1 is case-insensitive.
		#
		# @param fieldName [String]
		# @param outStr [CkString]
		#
		# @return [Boolean]
		def GetHeaderField(fieldName, outStr)
			# ...
		end


		# Method: GetHeaderField
		#
		# Returns the value of a MIME header field. ARG1 is case-insensitive.
		#
		# @param fieldName [String]
		#
		# @return [String]
		def getHeaderField(fieldName)
			# ...
		end


		# Method: GetHeaderFieldAttribute
		#
		# Parses a MIME header field and returns the value of an attribute. MIME header fields w/ attributes
		# are formatted like this:
		# 
		# Header-Name: value; attrName1="value1"; attrName2="value2";
		# .... attrNameN="valueN"
		# 
		# Semi-colons separate attribute name=value pairs. The
		# Content-Type header field often contains attributes. Here is an example:
		# 
		# Content-Type:
		# multipart/signed;
		# 	protocol="application/x-pkcs7-signature";
		# 	micalg=SHA1;
		# 	boundary="----=_NextPart_000_0000_01CB03E4.D0BAF010"
		# 
		# In
		# the above example, to access the value of the "protocol" attribute, call
		# GetHeaderFieldAttribute("Content-Type", "protocol");
		#
		# @param name [String]
		# @param attrName [String]
		# @param outStr [CkString]
		#
		# @return [Boolean]
		def GetHeaderFieldAttribute(name, attrName, outStr)
			# ...
		end


		# Method: GetHeaderFieldAttribute
		#
		# Parses a MIME header field and returns the value of an attribute. MIME header fields w/ attributes
		# are formatted like this:
		# 
		# Header-Name: value; attrName1="value1"; attrName2="value2";
		# .... attrNameN="valueN"
		# 
		# Semi-colons separate attribute name=value pairs. The
		# Content-Type header field often contains attributes. Here is an example:
		# 
		# Content-Type:
		# multipart/signed;
		# 	protocol="application/x-pkcs7-signature";
		# 	micalg=SHA1;
		# 	boundary="----=_NextPart_000_0000_01CB03E4.D0BAF010"
		# 
		# In
		# the above example, to access the value of the "protocol" attribute, call
		# GetHeaderFieldAttribute("Content-Type", "protocol");
		#
		# @param name [String]
		# @param attrName [String]
		#
		# @return [String]
		def getHeaderFieldAttribute(name, attrName)
			# ...
		end


		# Method: GetHeaderFieldName
		#
		# Returns the Nth MIME header field name.
		#
		# @param index [Fixnum]
		# @param outStr [CkString]
		#
		# @return [Boolean]
		def GetHeaderFieldName(index, outStr)
			# ...
		end


		# Method: GetHeaderFieldName
		#
		# Returns the Nth MIME header field name.
		#
		# @param index [Fixnum]
		#
		# @return [String]
		def getHeaderFieldName(index)
			# ...
		end


		# Method: GetHeaderFieldValue
		#
		# Returns the Nth MIME header field value.
		#
		# @param index [Fixnum]
		# @param outStr [CkString]
		#
		# @return [Boolean]
		def GetHeaderFieldValue(index, outStr)
			# ...
		end


		# Method: GetHeaderFieldValue
		#
		# Returns the Nth MIME header field value.
		#
		# @param index [Fixnum]
		#
		# @return [String]
		def getHeaderFieldValue(index)
			# ...
		end


		# Method: GetMime
		#
		# Returns a string containing the complete MIME message, including all sub-parts.
		#
		# @param outStr [CkString]
		#
		# @return [Boolean]
		def GetMime(outStr)
			# ...
		end


		# Method: GetMime
		#
		# Returns a string containing the complete MIME message, including all sub-parts.
		#
		#
		# @return [String]
		def getMime()
			# ...
		end


		# Method: GetMimeBd
		#
		# Appends the MIME to a BinData object.
		#
		# @param bindat [CkBinData]
		#
		# @return [Boolean]
		def GetMimeBd(bindat)
			# ...
		end


		# Method: GetMimeBytes
		#
		# Returns a byte array containing the complete MIME message, including all sub-parts.
		#
		# @param outBytes [CkByteData]
		#
		# @return [Boolean]
		def GetMimeBytes(outBytes)
			# ...
		end


		# Method: GetMimeSb
		#
		# Appends the MIME to a StringBuilder object.
		#
		# @param sb [CkStringBuilder]
		#
		# @return [Boolean]
		def GetMimeSb(sb)
			# ...
		end


		# Method: GetPart
		#
		# Returns the Nth sub-part of the MIME message. Indexing begins at 0.
		#
		# @param index [Fixnum]
		#
		# @return [CkMime]
		def GetPart(index)
			# ...
		end


		# Method: GetSignatureSigningTime
		#
		# Returns the signature signing date/time for the Nth signature. The number of signatures (i.e. signer
		# certs) is indicated by the NumSignerCerts property. The HasSignatureSigningTime method may be called
		# to determine if a signature timestamp is available. The index of the 1st signature signing time is
		# 0.
		#
		# @param index [Fixnum]
		#
		# @return [Boolean]
		# @deprecated This method has been deprecated. Do not use it.
		def GetSignatureSigningTime(index)
			# ...
		end


		# Method: GetSignatureSigningTimeStr
		#
		# The same as the GetSignatureSigningTime method, but returns tjhe date/time in RFC822 string format.
		#
		# @param index [Fixnum]
		# @param outStr [CkString]
		#
		# @return [Boolean]
		def GetSignatureSigningTimeStr(index, outStr)
			# ...
		end


		# Method: GetSignatureSigningTimeStr
		#
		# The same as the GetSignatureSigningTime method, but returns tjhe date/time in RFC822 string format.
		#
		# @param index [Fixnum]
		#
		# @return [String]
		def getSignatureSigningTimeStr(index)
			# ...
		end


		# Method: GetSignerCert
		#
		# Returns the Nth digital certificate used to sign the MIME message. Indexing begins at 0.
		#
		# @param index [Fixnum]
		#
		# @return [CkCert]
		def GetSignerCert(index)
			# ...
		end


		# Method: GetSignerCertChain
		#
		# Returns the full certificate chain for the Nth certificate used to sign the MIME message. Indexing
		# begins at 0.
		#
		# @param index [Fixnum]
		#
		# @return [CkCertChain]
		def GetSignerCertChain(index)
			# ...
		end


		# Method: GetStructure
		#
		# Returns a string summarizing the MIME structure. The output format is specified by ARG1 and can be
		# "text" or "xml".
		#
		# @param fmt [String]
		# @param outStr [CkString]
		#
		# @return [Boolean]
		def GetStructure(fmt, outStr)
			# ...
		end


		# Method: GetStructure
		#
		# Returns a string summarizing the MIME structure. The output format is specified by ARG1 and can be
		# "text" or "xml".
		#
		# @param fmt [String]
		#
		# @return [String]
		def getStructure(fmt)
			# ...
		end


		# Method: GetXml
		#
		# Converts the MIME (or S/MIME) message to XML and returns the XML as a string.
		#
		# @param outStr [CkString]
		#
		# @return [Boolean]
		def GetXml(outStr)
			# ...
		end


		# Method: GetXml
		#
		# Converts the MIME (or S/MIME) message to XML and returns the XML as a string.
		#
		#
		# @return [String]
		def getXml()
			# ...
		end


		# Method: HasSignatureSigningTime
		#
		# Returns _TRUE_ if the Nth signature included a timestamp that recorded the signing time. The number
		# of signatures (i.e. signer certs) is indicated by the NumSignerCerts property. (In most cases, the
		# number of signer certs is 1.) The signing time can be obtained via the GetSignatureSigningTime or
		# GetSignatureSigningTimeStr methods. The index of the 1st signature signing time is 0.
		#
		# @param index [Fixnum]
		#
		# @return [Boolean]
		def HasSignatureSigningTime(index)
			# ...
		end


		# Method: IsApplicationData
		#
		# Return _TRUE_ if the MIME message contains application data, otherwise returns _FALSE_.
		#
		#
		# @return [Boolean]
		def IsApplicationData()
			# ...
		end


		# Method: IsAttachment
		#
		# Return _TRUE_ if this MIME message is an attachment, otherwise returns _FALSE_. A MIME message is
		# considered an attachment if the Content-Disposition header field contains the value "attachment".
		#
		#
		# @return [Boolean]
		def IsAttachment()
			# ...
		end


		# Method: IsAudio
		#
		# Return _TRUE_ if the MIME message contains audio data, otherwise returns _FALSE_.
		#
		#
		# @return [Boolean]
		def IsAudio()
			# ...
		end


		# Method: IsEncrypted
		#
		# Returns _TRUE_ if the MIME message is PKCS7 encrypted, otherwise returns _FALSE_.
		#
		#
		# @return [Boolean]
		def IsEncrypted()
			# ...
		end


		# Method: IsHtml
		#
		# Return _TRUE_ if the MIME body is HTML, otherwise returns _FALSE_.
		#
		#
		# @return [Boolean]
		def IsHtml()
			# ...
		end


		# Method: IsImage
		#
		# Return _TRUE_ if the MIME message contains image data, otherwise returns _FALSE_.
		#
		#
		# @return [Boolean]
		def IsImage()
			# ...
		end


		# Method: IsMultipart
		#
		# Return _TRUE_ if the MIME message is multipart (multipart/mixed, multipart/related,
		# multipart/alternative, etc.), otherwise returns _FALSE_.
		#
		#
		# @return [Boolean]
		def IsMultipart()
			# ...
		end


		# Method: IsMultipartAlternative
		#
		# Return _TRUE_ if the MIME message is multipart/alternative, otherwise returns _FALSE_.
		#
		#
		# @return [Boolean]
		def IsMultipartAlternative()
			# ...
		end


		# Method: IsMultipartMixed
		#
		# Return true if the MIME message is multipart/mixed, otherwise returns _FALSE_.
		#
		#
		# @return [Boolean]
		def IsMultipartMixed()
			# ...
		end


		# Method: IsMultipartRelated
		#
		# Return _TRUE_ if the MIME message is multipart/related, otherwise returns _FALSE_.
		#
		#
		# @return [Boolean]
		def IsMultipartRelated()
			# ...
		end


		# Method: IsPlainText
		#
		# Return _TRUE_ if the MIME message body is plain text, otherwise returns _FALSE_.
		#
		#
		# @return [Boolean]
		def IsPlainText()
			# ...
		end


		# Method: IsSigned
		#
		# Return _TRUE_ if the MIME message is PKCS7 digitally signed, otherwise returns _FALSE_.
		#
		#
		# @return [Boolean]
		def IsSigned()
			# ...
		end


		# Method: IsText
		#
		# Return _TRUE_ if the MIME message body is any text content type, such as text/plain, text/html,
		# text/xml, etc., otherwise returns _FALSE_.
		#
		#
		# @return [Boolean]
		def IsText()
			# ...
		end


		# Method: IsUnlocked
		#
		# Returns _TRUE_ if the component is already unlocked, otherwise returns _FALSE_.
		#
		#
		# @return [Boolean]
		def IsUnlocked()
			# ...
		end


		# Method: IsVideo
		#
		# Return _TRUE_ if the MIME message contains video data, otherwise returns _FALSE_.
		#
		#
		# @return [Boolean]
		def IsVideo()
			# ...
		end


		# Method: IsXml
		#
		# Return _TRUE_ if the MIME message body is XML, otherwise returns _FALSE_.
		#
		#
		# @return [Boolean]
		def IsXml()
			# ...
		end


		# Method: LoadMime
		#
		# Discards the current contents of the MIME object and loads a new MIME message from a string.
		#
		# @param mimeMsg [String]
		#
		# @return [Boolean]
		def LoadMime(mimeMsg)
			# ...
		end


		# Method: LoadMimeBd
		#
		# Discards the current contents of the MIME object and loads a new MIME message from a BinData object.
		#
		# @param bindat [CkBinData]
		#
		# @return [Boolean]
		def LoadMimeBd(bindat)
			# ...
		end


		# Method: LoadMimeBytes
		#
		# Loads a MIME document from an in-memory byte array.
		#
		# @param binData [CkByteData]
		#
		# @return [Boolean]
		def LoadMimeBytes(binData)
			# ...
		end


		# Method: LoadMimeFile
		#
		# Discards the current contents of the MIME object and loads a new MIME message from a file.
		#
		# @param fileName [String]
		#
		# @return [Boolean]
		def LoadMimeFile(fileName)
			# ...
		end


		# Method: LoadMimeSb
		#
		# Discards the current contents of the MIME object and loads a new MIME message from a StringBuilder.
		#
		# @param sb [CkStringBuilder]
		#
		# @return [Boolean]
		def LoadMimeSb(sb)
			# ...
		end


		# Method: LoadXml
		#
		# Converts XML to MIME and replaces the MIME object's contents with the converted XML.
		#
		# @param xml [String]
		#
		# @return [Boolean]
		def LoadXml(xml)
			# ...
		end


		# Method: LoadXmlFile
		#
		# Converts XML to MIME and replaces the MIME object's contents with the converted XML.
		#
		# @param fileName [String]
		#
		# @return [Boolean]
		def LoadXmlFile(fileName)
			# ...
		end


		# Method: NewMessageRfc822
		#
		# Clears the Mime object and initializes it such that the header contains a "content-type:
		# message/rfc822" line and the body is the MIME text of the Mime object passed to the method.
		#
		# @param mimeObject [CkMime]
		#
		# @return [Boolean]
		def NewMessageRfc822(mimeObject)
			# ...
		end


		# Method: NewMultipartAlternative
		#
		# Discards the current MIME message header fields and contents, if any, an initializes the MIME object
		# to be an empty mulipart/alternative message.
		#
		#
		# @return [Boolean]
		def NewMultipartAlternative()
			# ...
		end


		# Method: NewMultipartMixed
		#
		# Discards the current MIME message header fields and contents, if any, an initializes the MIME object
		# to be an empty mulipart/mixed message.
		#
		#
		# @return [Boolean]
		def NewMultipartMixed()
			# ...
		end


		# Method: NewMultipartRelated
		#
		# Discards the current MIME message header fields and contents, if any, an initializes the MIME object
		# to be an empty mulipart/related message.
		#
		#
		# @return [Boolean]
		def NewMultipartRelated()
			# ...
		end


		# Method: RemoveHeaderField
		#
		# Removes a header field from the MIME header. If ARG2 is _TRUE_, then all occurrences of the header
		# field are removed. Otherwise, only the 1st occurrence is removed.
		#
		# @param fieldName [String]
		# @param bAllOccurrences [Boolean]
		#
		# @return [nil]
		def RemoveHeaderField(fieldName, bAllOccurrences)
			# ...
		end


		# Method: RemovePart
		#
		# Removes the Nth subpart from the MIME message.
		#
		# @param index [Fixnum]
		#
		# @return [Boolean]
		def RemovePart(index)
			# ...
		end


		# Method: SaveBody
		#
		# Saves the MIME message body to a file. If the body is base64 or quoted-printable encoded, it is
		# automatically decoded.
		#
		# @param filename [String]
		#
		# @return [Boolean]
		def SaveBody(filename)
			# ...
		end


		# Method: SaveLastError
		#
		# Saves the last-error information (the contents of LastErrorXml) to an XML formatted file.
		#
		# @param path [String]
		#
		# @return [Boolean]
		def SaveLastError(path)
			# ...
		end


		# Method: SaveMime
		#
		# Saves the MIME message to a file, in MIME format. (This is the same as the .EML format used by
		# Microsoft Outlook Express.)
		#
		# @param filename [String]
		#
		# @return [Boolean]
		def SaveMime(filename)
			# ...
		end


		# Method: SaveXml
		#
		# Converts the MIME message to XML and saves to an XML file.
		#
		# @param filename [String]
		#
		# @return [Boolean]
		def SaveXml(filename)
			# ...
		end


		# Method: SetBody
		#
		# Sets the MIME body content to a text string.
		#
		# @param str [String]
		#
		# @return [nil]
		def SetBody(str)
			# ...
		end


		# Method: SetBodyFromBinary
		#
		# Sets the MIME message body from a byte array.
		#
		# @param binData [CkByteData]
		#
		# @return [Boolean]
		def SetBodyFromBinary(binData)
			# ...
		end


		# Method: SetBodyFromEncoded
		#
		# Sets the MIME message body from a Base64 or Quoted-Printable encoded string.
		#
		# @param encoding [String]
		# @param str [String]
		#
		# @return [Boolean]
		def SetBodyFromEncoded(encoding, str)
			# ...
		end


		# Method: SetBodyFromFile
		#
		# Sets the MIME message body from the contents of a file. Note: A MIME message consists of a header
		# and a body. The body may itself be a MIME message that consists of a header and body, etc. This
		# method loads the contents of a file into the body of a MIME message, without replacing the header.
		# # The Content-Type and Content-Transfer-Encoding header fields are automatically updated to match
		# the type of content loaded (based on file extension). If your application requires the MIME to have
		# a specific Content-Type and/or Content-Transfer-Encoding, set the ContentType and Encoding
		# properties after calling this method (not before).
		#
		# @param fileName [String]
		#
		# @return [Boolean]
		def SetBodyFromFile(fileName)
			# ...
		end


		# Method: SetBodyFromHtml
		#
		# Sets the MIME message body from a string containing HTML. The Content-Type header is added or
		# updated to the value "text/html". 
		# If 8bit (non-us-ascii) characters are present, and if the
		# Charset property was not previously set, then the "charset" attribute is automatically added to the
		# Content-Type header using the default value of "utf-8". This can be changed at any time by setting
		# the Charset property.
		# 
		# If the Encoding property was not previously set, then the
		# Content-Transfer-Encoding header is automatically added. It will be set to "7bit" or "8bit"
		# depending on whether the HTML body contains 8-bit non-us-ascii characters.
		# To set the MIME
		# body with no intentional side-effects, use SetBody instead.
		#
		# @param str [String]
		#
		# @return [Boolean]
		def SetBodyFromHtml(str)
			# ...
		end


		# Method: SetBodyFromPlainText
		#
		# Sets the MIME message body from a string containing plain-text. The Content-Type header is added or
		# updated to the value "text/plain". 
		# If 8bit (non-us-ascii) characters are present, and if the
		# Charset property was not previously set, then the "charset" attribute is automatically added to the
		# Content-Type header using the default value of "utf-8". This can be changed at any time by setting
		# the Charset property.
		# 
		# If the Encoding property was not previously set, then the
		# Content-Transfer-Encoding header is automatically added. It will be set to "7bit" or "8bit"
		# depending on whether the plain-text body contains 8-bit non-us-ascii characters.
		# To set the
		# MIME body with no intentional side-effects, use SetBody instead.
		#
		# @param str [String]
		#
		# @return [Boolean]
		def SetBodyFromPlainText(str)
			# ...
		end


		# Method: SetBodyFromXml
		#
		# Sets the MIME message body from a string containing XML. The Content-Type header is added or updated
		# to the value "text/xml". 
		# If 8bit (non-us-ascii) characters are present, and if the Charset
		# property was not previously set, then the "charset" attribute is automatically added to the
		# Content-Type header using the default value of "utf-8". This can be changed at any time by setting
		# the Charset property.
		# 
		# If the Encoding property was not previously set, then the
		# Content-Transfer-Encoding header is automatically added. It will be set to "7bit" or "8bit"
		# depending on whether the plain-text body contains 8-bit non-us-ascii characters.
		# To set the
		# MIME body with no intentional side-effects, use SetBody instead.
		#
		# @param str [String]
		#
		# @return [Boolean]
		def SetBodyFromXml(str)
			# ...
		end


		# Method: SetCSP
		#
		# (Only applies to the Microsoft Windows OS) Sets the Cryptographic Service Provider (CSP) to be used
		# for encryption / signing, or decryption / signature verification.
		# 
		# This is not commonly
		# used becaues the default Microsoft CSP is typically appropriate. 
		# One instance where SetCSP is
		# necessary is when using the Crypto-Pro CSP for the GOST R 34.10-2001 and GOST R 34.10-94 providers.
		#
		# @param csp [CkCsp]
		#
		# @return [Boolean]
		def SetCSP(csp)
			# ...
		end


		# Method: SetHeaderField
		#
		# Adds or replaces a MIME message header field. If the field already exists, it is automatically
		# replaced. Otherwise it is added. Pass zero-length ARG2 to remove the header field.
		#
		# @param name [String]
		# @param value [String]
		#
		# @return [Boolean]
		def SetHeaderField(name, value)
			# ...
		end


		# Method: SetVerifyCert
		#
		# Allows a certificate to be explicitly specified for verifying a signature.
		#
		# @param cert [CkCert]
		#
		# @return [Boolean]
		def SetVerifyCert(cert)
			# ...
		end


		# Method: UnlockComponent
		#
		# Unlocks the component allowing for the full functionality to be used. If this method unexpectedly
		# returns _FALSE_, examine the contents of the LastErrorText property to determine the reason for
		# failure.
		#
		# @param unlockCode [String]
		#
		# @return [Boolean]
		def UnlockComponent(unlockCode)
			# ...
		end


		# Method: UnwrapSecurity
		#
		# Decrypts and/or verifies all digital signatures contained within the MIME message, and returns
		# _TRUE_ if all decryptions and verifications succeeded. Otherwise returns _FALSE_. After unwrapping,
		# the information regarding security and certificates can be obtained by the methods GetSignerCert and
		# GetEncryptCert, and the properties NumEncryptCerts and NumSignerCerts.
		# The MIME is restored to
		# the original structure/content prior to all signing and/or encryption.
		# The difference between
		# UnwrapSecurity and methods such as Verify or Decrypt is that UnwrapSecurity will recursively
		# traverse the MIME to decrypt and/or verify all parts. Also, UnwrapSecurity will unwrap layers until
		# no further encrypted/signed content is found. For example, if a MIME message was encrypted and then
		# subsequently signed, then UnwrapSecurity will verify and unwrap the detached signature/signed-data
		# layer, and then decrypt the "enveloped data".
		#
		#
		# @return [Boolean]
		def UnwrapSecurity()
			# ...
		end


		# Method: UrlEncodeBody
		#
		# URL encodes the MIME body. The ARG1 is important. For example, consider this
		# MIME:
		# 
		# Content-Type: text/plain
		# Content-Transfer-Encoding:
		# 8bit
		# 
		# Société
		# 
		# If the ARG1 is set to "utf-8", then the following is
		# produced:
		# 
		# Content-Type: text/plain
		# Content-Transfer-Encoding:
		# 8bit
		# 
		# Soci%C3%A9t%C3%A9
		# 
		# However, if the ARG1 is set to "ansi", then the
		# following is the result:
		# 
		# Content-Type: text/plain
		# Content-Transfer-Encoding:
		# 8bit
		# 
		# Soci%E9t%E9
		#
		#
		# @param charset [String]
		#
		# @return [nil]
		def UrlEncodeBody(charset)
			# ...
		end


		# Method: UseCertVault
		#
		# Adds an XML certificate vault to the object's internal list of sources to be searched for
		# certificates and private keys when encrypting/decrypting or signing/verifying. Unlike the
		# AddPfxSourceData and AddPfxSourceFile methods, only a single XML certificate vault can be used. If
		# UseCertVault is called multiple times, only the last certificate vault will be used, as each call to
		# UseCertVault will replace the certificate vault provided in previous calls.
		#
		# @param vault [CkXmlCertVault]
		#
		# @return [Boolean]
		def UseCertVault(vault)
			# ...
		end


		# Method: Verify
		#
		# Verifies PKCS7 signed MIME and "unwraps" the signature. The MIME is restored to the original
		# structure that it would have originally had prior to signing. The Verify method works with both
		# detached signatures, as well as opaque/attached signatures.
		# A PKCS7 signature usually embeds
		# both the signing certificate with its public key. Therefore, it is usually possible to verify a
		# signature without the need to already have the certificate installed. If the signature does not
		# embed the certificate, the Verify method will automatically locate and use the certificate if it was
		# correctly pre-installed on the computer.
		#
		#
		# @return [Boolean]
		def Verify()
			# ...
		end

	end
end
